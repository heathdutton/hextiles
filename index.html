<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gametile Designer — Interlocking Board Game Tile Generator for Laser Cutting</title>
<meta name="description" content="Free interactive tool to design interlocking laser-cut board game tiles. Triangle, square, and hexagon shapes with twist-lock joints. Adjust angle, radius, rounding, thickness. Physics-based interlock and durability gauges. Export production-ready SVG.">
<meta name="keywords" content="board game tiles, laser cutting, hex tiles, triangle tiles, square tiles, interlocking tiles, twist joint, SVG export, game tile designer, tabletop game, Catan tiles, laser cut wood, tile generator">
<meta name="author" content="Heath Dutton">
<meta name="robots" content="index, follow">
<meta property="og:title" content="Gametile Designer — Interlocking Tile Generator">
<meta property="og:description" content="Free tool to design interlocking laser-cut board game tiles. Triangle, square, hexagon with twist-lock joints. Adjust parameters, preview in 3D, export SVG.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://heathdutton.github.io/gametile-designer/">
<meta property="og:image" content="https://heathdutton.github.io/gametile-designer/screenshot.png">
<meta property="og:image:alt" content="Gametile Designer showing interlocking hexagon tiles with twist joints">
<meta property="og:site_name" content="Gametile Designer">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Gametile Designer — Interlocking Tile Generator">
<meta name="twitter:description" content="Design interlocking laser-cut board game tiles. Triangle, square, hexagon with twist-lock joints. Free, no install. Export SVG.">
<meta name="twitter:image" content="https://heathdutton.github.io/gametile-designer/screenshot.png">
<link rel="canonical" href="https://heathdutton.github.io/gametile-designer/">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebApplication",
  "name": "Gametile Designer",
  "url": "https://heathdutton.github.io/gametile-designer/",
  "description": "Interactive design tool for interlocking laser-cut board game tiles with twist-lock joints. Supports triangle, square, and hexagon shapes. Export SVG for laser cutting.",
  "applicationCategory": "DesignApplication",
  "operatingSystem": "Any",
  "offers": { "@type": "Offer", "price": "0", "priceCurrency": "USD" },
  "screenshot": "https://heathdutton.github.io/gametile-designer/screenshot.png",
  "author": { "@type": "Person", "name": "Heath Dutton" }
}
</script>
<style>
  :root {
    --bg: #1a1a2e;
    --sidebar: #16213e;
    --canvas: #0f3460;
    --border: #2a2a4e;
    --accent: #e94560;
    --accent-hover: #c73650;
    --label: #bbb;
    --muted: #555;
    --link: #7ba4cc;
    --overlay-bg: #1a1a2e;
    --tile-stroke: #1a1a2e;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: 'Segoe UI', system-ui, sans-serif;
    background: var(--bg);
    color: #eee;
    display: flex;
    height: 100vh;
    overflow: hidden;
    transition: background-color 0.6s ease;
  }
  #sidebar {
    width: 300px;
    padding: 24px;
    background: var(--sidebar);
    overflow-y: auto;
    flex-shrink: 0;
    border-right: 1px solid var(--border);
    transition: background-color 0.6s ease, border-color 0.6s ease;
  }
  #main {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    min-width: 0;
    min-height: 0;
    position: relative;
  }
  canvas {
    display: block;
    background: var(--canvas);
    transition: background-color 0.6s ease;
  }
  h1 { font-size: 20px; margin-bottom: 4px; color: var(--accent); transition: color 0.6s ease; }
  .subtitle { font-size: 12px; color: var(--muted); margin-bottom: 20px; }
  .section-wrap summary button {
    font-size: 10px; color: var(--muted); background: none; border: 1px solid var(--border);
    border-radius: 4px; padding: 2px 8px; cursor: pointer; float: right;
    transition: color 0.15s, border-color 0.15s; text-transform: none; letter-spacing: 0;
  }
  .section-wrap summary button:hover { color: var(--accent); border-color: var(--accent); }
  .group { margin-bottom: 14px; }
  .group > label { display: block; font-size: 13px; margin-bottom: 4px; color: var(--label); cursor: pointer; }
  .group > label:hover { color: var(--accent); }
  .group label span { float: right; color: var(--accent); font-weight: bold; cursor: text; }
  .group label span:hover { text-decoration: underline; }
  .val-input {
    float: right; width: 70px; background: var(--bg); color: var(--accent);
    border: 1px solid var(--accent); border-radius: 3px; font-size: 12px;
    font-weight: bold; text-align: right; padding: 0 4px; outline: none;
    font-family: inherit;
  }
  input[type=range] { width: 100%; accent-color: var(--accent); }
  .cb { margin-bottom: 10px; }
  .cb label { font-size: 13px; color: var(--label); cursor: pointer; display: flex; align-items: center; gap: 8px; }
  .cb input { accent-color: var(--accent); }
  #export-btn {
    width: 100%; padding: 10px; background: var(--accent); color: var(--bg);
    border: none; border-radius: 6px; cursor: pointer; font-size: 13px; margin-top: 8px; font-weight: 600;
    transition: background-color 0.6s ease, color 0.6s ease;
  }
  #export-btn:hover { background: var(--accent-hover); }
  #export-grid-btn {
    width: 100%; padding: 8px; background: transparent; color: var(--accent);
    border: 1px solid var(--accent); border-radius: 6px; cursor: pointer; font-size: 12px; margin-top: 6px;
    transition: color 0.6s ease, border-color 0.6s ease;
  }
  #export-grid-btn:hover { background: rgba(200,200,200,0.08); background: color-mix(in srgb, var(--accent) 10%, transparent); }
  #demo-btn {
    width: 100%; padding: 8px; background: transparent; color: var(--muted);
    border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 12px; margin-top: 6px;
  }
  #demo-btn:hover { border-color: var(--accent); color: var(--accent); }
  #demo-btn.active { border-color: var(--accent); color: var(--bg); background: var(--accent); }
  .info { font-size: 11px; color: var(--muted); margin-top: 16px; line-height: 1.6; }
  .examples { font-size: 12px; }
  .examples a { display: block; color: var(--link); text-decoration: none; padding: 2px 0; }
  .examples a:hover { color: var(--accent); }
  .examples .ex-cat { font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--muted); margin: 8px 0 2px; font-weight: 600; }
  .examples .ex-cat:first-of-type { margin-top: 4px; }

  /* Interlock gauge */
  .gauge { margin: 16px 0 6px; }
  .gauge-label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: var(--muted); margin-bottom: 8px; border-top: 1px solid var(--border); padding-top: 14px; transition: color 0.6s ease, border-color 0.6s ease; }
  .gauge-track {
    height: 10px; border-radius: 5px; position: relative;
    background: linear-gradient(to right, #4a7fb5, #2a9d8f 25%, #8ab840 45%, #f4a261 65%, #e94560 85%, #a00030);
    overflow: visible;
  }
  .gauge-pip {
    position: absolute; top: -3px; width: 4px; height: 16px;
    background: #fff; border-radius: 2px;
    transform: translateX(-2px);
    box-shadow: 0 0 6px rgba(255,255,255,0.5);
    transition: left 0.1s ease;
  }
  .gauge-labels {
    display: flex; justify-content: space-between;
    font-size: 10px; color: #777; margin-top: 5px;
  }
  .gauge-readout {
    text-align: center; font-size: 13px; font-weight: bold;
    margin-top: 6px; letter-spacing: 0.5px;
  }
  .gauge-detail {
    text-align: center; font-size: 10px; color: #666; margin-top: 2px;
  }
  select, input[type=number] {
    background: var(--bg); color: #eee; border: 1px solid var(--border);
    border-radius: 4px; padding: 3px 6px; font-size: 12px;
  }
  select { cursor: pointer; }
  input[type=number] { width: 70px; }

  /* Pill switch */
  .pill-switch {
    display: flex; border-radius: 8px; overflow: hidden;
    border: 1px solid var(--border); margin-bottom: 20px;
  }
  .pill-switch input { display: none; }
  .pill-switch label {
    flex: 1; text-align: center; padding: 8px 0; font-size: 13px;
    font-weight: 600; color: var(--label); cursor: pointer;
    background: var(--bg); transition: background 0.15s, color 0.15s;
    border-right: 1px solid var(--border);
  }
  .pill-switch label:last-of-type { border-right: none; }
  .pill-switch input:checked + label {
    background: var(--accent); color: var(--bg);
  }
  .export-row { display: flex; gap: 8px; align-items: center; margin-top: 8px; }
  .export-row label { font-size: 12px; color: var(--label); white-space: nowrap; }

  /* Stats overlay */
  #stats-overlay {
    position: absolute; bottom: 32px; left: 32px;
    background: var(--overlay-bg);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 14px 18px;
    min-width: 260px;
    max-width: 340px;
    pointer-events: auto;
    box-shadow: 0 4px 12px rgba(0,0,0,0.25);
  }
  .overlay-close {
    position: absolute; top: 6px; right: 8px;
    background: none; border: none; color: #555; font-size: 13px;
    cursor: pointer; padding: 2px 5px; line-height: 1;
  }
  .overlay-close:hover { color: var(--accent); }
  #stats-overlay .gauge { margin: 0 0 10px; }
  #stats-overlay .gauge:last-child { margin-bottom: 0; }
  #stats-overlay .gauge-label { border-top: none; padding-top: 0; margin-bottom: 6px; }
  #stats-overlay .gauge-label:not(:first-child) { border-top: 1px solid rgba(255,255,255,0.06); padding-top: 10px; margin-top: 4px; }

  /* Mobile toggle button — hidden on desktop */
  #sidebar-toggle {
    display: none;
    position: fixed; bottom: 16px; right: 16px; z-index: 100;
    width: 48px; height: 48px; border-radius: 50%;
    background: var(--accent); color: var(--bg); border: none;
    font-size: 22px; cursor: pointer;
    box-shadow: 0 3px 12px rgba(0,0,0,0.4);
    transition: transform 0.15s;
  }
  #sidebar-toggle:active { transform: scale(0.9); }

  /* Collapsible sections (native details/summary) */
  .section-wrap { margin-top: 20px; border-top: 1px solid var(--border); padding-top: 14px; }
  .section-wrap summary {
    font-size: 11px; text-transform: uppercase; letter-spacing: 1px;
    color: var(--muted); cursor: pointer; user-select: none; list-style: disclosure-closed;
    margin-bottom: 12px;
  }
  .section-wrap[open] summary { list-style: disclosure-open; }

  /* Mobile layout */
  @media (max-width: 768px) {
    body { flex-direction: column; height: auto; overflow: auto; }
    #sidebar {
      width: 100%; border-right: none; border-top: 1px solid var(--border);
      order: 2; padding: 16px 20px;
      max-height: none;
    }
    #sidebar.hidden { display: none; }
    #main { width: 100%; height: 55vh; min-height: 280px; order: 1; }
    #sidebar-toggle { display: block; }
    #stats-overlay { bottom: 12px; left: 12px; min-width: 200px; max-width: 280px; font-size: 11px; }
    #stats-overlay .gauge-label { font-size: 10px; }
    .pill-switch label { padding: 6px 0; font-size: 12px; }
    h1 { font-size: 17px; }
  }
  @media (max-width: 480px) {
    #main { height: 45vh; min-height: 240px; }
    #stats-overlay { display: none; }
  }
</style>
</head>
<body>

<div id="sidebar">
  <h1>Gametile Designer</h1>
  <div class="subtitle">Soft-interlocking game tiles</div>

  <details class="section-wrap" open>
  <summary>Tile Parameters <button id="randomize-btn">Randomize</button></summary>
  <div class="pill-switch" style="margin-bottom:10px">
    <input type="radio" name="sides" id="sides-3" value="3"><label for="sides-3">&#9651; Tri</label>
    <input type="radio" name="sides" id="sides-4" value="4"><label for="sides-4">&#9633; Quad</label>
    <input type="radio" name="sides" id="sides-6" value="6" checked><label for="sides-6">&#11042; Hex</label>
  </div>
  <div class="group">
    <label>Twist Angle <span id="v-angle">32.0&deg;</span></label>
    <input type="range" id="angle" min="-55" max="55" step="0.5" value="32">
  </div>
  <div class="group">
    <label>Twist Radius <span id="v-radius">0.17 &times; side</span></label>
    <input type="range" id="radius" min="0" max="0.5" step="0.01" value="0.17">
  </div>
  <div class="group" style="margin-bottom:14px">
    <label style="margin-bottom:6px">Twist Type</label>
    <div class="pill-switch" style="margin-bottom:0">
      <input type="radio" name="joint" id="joint-angular" value="1" checked><label for="joint-angular">Angular</label>
      <input type="radio" name="joint" id="joint-circular" value="0"><label for="joint-circular">Circular</label>
    </div>
  </div>

  <div class="group">
    <label>Edge Rounding <span id="v-round-edge">0.030 &times; side</span></label>
    <input type="range" id="round-edge" min="0" max="0.1" step="0.001" value="0.03">
  </div>
  <div class="group">
    <label>Vertex Rounding <span id="v-round-vtx">0.030 &times; side</span></label>
    <input type="range" id="round-vtx" min="0" max="0.25" step="0.005" value="0.03">
  </div>
  <div class="group">
    <label>Side Smoothing <span id="v-side-smooth">0%</span></label>
    <input type="range" id="side-smooth" min="0" max="100" step="1" value="0">
  </div>
  <div class="group">
    <label>Tile Thickness <span id="v-thickness">2.0 mm</span></label>
    <input type="range" id="thickness" min="0.5" max="6" step="0.1" value="2">
  </div>
  <div class="group">
    <label>Tile Side Length <span id="v-export-size">30 mm</span></label>
    <input type="range" id="export-size" min="10" max="60" step="1" value="30">
  </div>
  <div class="gauge-detail" id="hex-dims"></div>
  </details>

  <details class="section-wrap" open>
  <summary>Display Options <button id="randomize-display-btn">Randomize</button></summary>
  <div class="group">
    <label>Theme
      <select id="scheme" style="float: right;">
        <option value="0">Neon</option>
        <option value="1">Berry</option>
        <option value="2">Earth</option>
        <option value="3">Ocean</option>
        <option value="4">Slate</option>
        <option value="5">Synth</option>
        <option value="6">Ember</option>
        <option value="7">Moss</option>
      </select>
    </label>
  </div>
  <div class="group">
    <label>Zoom <span id="v-size">85%</span></label>
    <input type="range" id="size" min="8" max="200" step="0.1" value="85">
  </div>
  <div class="group">
    <label>Grid Size <span id="v-grid">5</span></label>
    <input type="range" id="grid" min="3" max="20" step="1" value="5">
  </div>
  <div class="group">
    <label>Explode <span id="v-explode">0%</span></label>
    <input type="range" id="explode" min="0" max="60" step="0.1" value="0">
  </div>
  <div class="group">
    <label>Tilt <span id="v-tilt">40°</span></label>
    <input type="range" id="tilt" min="0" max="60" step="0.1" value="40">
  </div>
  <div class="group" id="perspective-group">
    <label>Perspective <span id="v-perspective">45%</span></label>
    <input type="range" id="perspective" min="1" max="70" step="0.1" value="45">
  </div>
  <div class="group">
    <label>Rotation <span id="v-rotation">0°</span></label>
    <input type="range" id="rotation" min="-180" max="180" step="0.1" value="0">
  </div>
  <div class="cb"><label><input type="checkbox" id="show-original"> Show original outline</label></div>
  <div class="cb"><label><input type="checkbox" id="show-circles"> Show twist circles</label></div>
  <div class="cb"><label><input type="checkbox" id="show-single" checked> Show isolated tile</label></div>
  <div class="cb"><label><input type="checkbox" id="show-junction" checked> Show tile junction</label></div>
  <div class="cb"><label><input type="checkbox" id="show-stats" checked> Show stats</label></div>
  </details>

  <button id="export-btn">Export Tile as SVG</button>
  <button id="export-grid-btn">Export Tile Grid as SVG</button>
  <button id="demo-btn">Play Demo</button>

  <details class="section-wrap examples">
    <summary>Examples</summary>

    <div class="ex-cat">Hexagon</div>
    <a href="#sides=6&angle=0&radius=0&round-edge=0&round-vtx=0&thickness=2&export-size=26&size=85&grid=5&explode=0&tilt=40&perspective=45&angular=1&show-original=0&show-circles=0&show-single=0&show-junction=0&show-stats=0&scheme=0">Catan classic (26mm, no interlock)</a>
    <a href="#sides=6&angle=6&radius=0.25&round-edge=0.02&round-vtx=0&thickness=3&export-size=26&size=85&grid=5&explode=0&tilt=40&perspective=45&angular=1&show-original=0&show-circles=0&show-single=1&show-junction=1&show-stats=1&scheme=0">Catan gentle lock (26mm)</a>
    <a href="#sides=6&angle=32&radius=0.17&round-edge=0.03&round-vtx=0.03&thickness=2&export-size=30&size=85&grid=5&explode=0&tilt=40&perspective=45&angular=1&show-original=0&show-circles=0&show-single=1&show-junction=1&show-stats=1&scheme=0">Hex default (30mm)</a>
    <a href="#sides=6&angle=20&radius=0.35&round-edge=0.03&round-vtx=0.01&thickness=3&export-size=40&size=85&grid=5&explode=0&tilt=40&perspective=45&angular=0&show-original=0&show-circles=0&show-single=1&show-junction=1&show-stats=1&scheme=0">Tight puzzle (arc, 40mm)</a>
    <a href="#sides=6&angle=45&radius=0.3&round-edge=0.04&round-vtx=0.02&thickness=3&export-size=50&size=85&grid=5&explode=15&tilt=40&perspective=45&angular=1&show-original=0&show-circles=0&show-single=1&show-junction=1&show-stats=1&scheme=3">Decorative (high twist, exploded)</a>
    <a href="#sides=6&angle=32&radius=0.17&round-edge=0.03&round-vtx=0.03&thickness=3&export-size=30&size=85&grid=7&explode=0&tilt=35&perspective=35&angular=1&show-original=0&show-circles=0&show-single=0&show-junction=0&show-stats=0&scheme=5">3D showcase (tilted, Synth)</a>

    <div class="ex-cat">Square</div>
    <a href="#sides=4&angle=12&radius=0.18&round-edge=0.02&round-vtx=0.02&thickness=3&export-size=30&size=85&grid=5&explode=0&tilt=40&perspective=45&angular=1&show-original=0&show-circles=0&show-single=1&show-junction=1&show-stats=1&scheme=0">Gentle snap (30mm)</a>
    <a href="#sides=4&angle=25&radius=0.2&round-edge=0.02&round-vtx=0.02&thickness=3&export-size=30&size=85&grid=5&explode=0&tilt=40&perspective=45&angular=1&show-original=0&show-circles=0&show-single=1&show-junction=1&show-stats=1&scheme=0">Standard lock (30mm)</a>
    <a href="#sides=4&angle=38&radius=0.3&round-edge=0.03&round-vtx=0.01&thickness=3&export-size=35&size=85&grid=5&explode=0&tilt=40&perspective=45&angular=0&show-original=0&show-circles=0&show-single=1&show-junction=1&show-stats=1&scheme=2">Tight puzzle (arc, 35mm, Earth)</a>
    <a href="#sides=4&angle=25&radius=0.2&round-edge=0.02&round-vtx=0.02&thickness=4&export-size=40&size=75&grid=7&explode=8&tilt=30&perspective=40&angular=1&show-original=0&show-circles=0&show-single=0&show-junction=0&show-stats=0&scheme=4">Checkerboard 3D (exploded, Slate)</a>

    <div class="ex-cat">Triangle</div>
    <a href="#sides=3&angle=8&radius=0.15&round-edge=0.02&round-vtx=0.01&thickness=3&export-size=30&size=85&grid=5&explode=0&tilt=40&perspective=45&angular=1&show-original=0&show-circles=0&show-single=1&show-junction=1&show-stats=1&scheme=0">Gentle snap (30mm)</a>
    <a href="#sides=3&angle=15&radius=0.2&round-edge=0.02&round-vtx=0.01&thickness=3&export-size=30&size=85&grid=5&explode=0&tilt=40&perspective=45&angular=1&show-original=0&show-circles=0&show-single=1&show-junction=1&show-stats=1&scheme=0">Standard lock (30mm)</a>
    <a href="#sides=3&angle=25&radius=0.3&round-edge=0.03&round-vtx=0.01&thickness=3&export-size=35&size=85&grid=5&explode=0&tilt=40&perspective=45&angular=0&show-original=0&show-circles=0&show-single=1&show-junction=1&show-stats=1&scheme=1">Tight puzzle (arc, 35mm, Berry)</a>
    <a href="#sides=3&angle=15&radius=0.2&round-edge=0.02&round-vtx=0.01&thickness=3&export-size=30&size=70&grid=7&explode=10&tilt=25&perspective=35&angular=1&show-original=0&show-circles=0&show-single=0&show-junction=0&show-stats=0&scheme=3">Mosaic 3D (exploded, Ocean)</a>
  </details>

  <div class="info">
    Edges are twisted at each vertex within the twist radius, giving every
    side a tab and matching notch. Tiles drop in from above and resist
    sliding apart. Side smoothing adds S-curves between joints for
    rounder shapes. Edge and vertex rounding soften corners. Click any
    label to zero it; click a value to type one in (even beyond slider
    limits). Scroll to zoom; drag to pan. Export single tiles or full
    grids as SVG. All settings save in the URL.
  </div>
  <a href="https://github.com/heathdutton/gametile-designer" target="_blank" rel="noopener noreferrer" style="display:inline-flex; align-items:center; gap:6px; margin-top:16px; font-size:12px; color:var(--label); text-decoration:none; border:1px solid var(--border); border-radius:6px; padding:6px 12px; transition:border-color 0.15s, color 0.15s;" onmouseover="this.style.borderColor=this.style.color='var(--accent)'" onmouseout="this.style.borderColor='var(--border)';this.style.color='var(--label)'"><svg height="16" width="16" viewBox="0 0 16 16" fill="currentColor"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg>GitHub</a>
</div>

<div id="main">
  <canvas id="c" role="img" aria-label="Interactive board game tile preview with interlocking twist joints">Tile preview — requires JavaScript</canvas>
  <noscript><p style="color:#eee;text-align:center;padding:40px;">Gametile Designer requires JavaScript to run. Please enable JavaScript in your browser.</p></noscript>
  <div id="stats-overlay">
    <button class="overlay-close" id="close-stats-btn" aria-label="Close stats">&times;</button>
    <div class="gauge">
      <div class="gauge-label">Feel</div>
      <div class="gauge-track"><div class="gauge-pip" id="gauge-pip"></div></div>
      <div class="gauge-labels">
        <span>Loose</span>
        <span>Snug</span>
        <span>Firm</span>
        <span>Locked</span>
      </div>
      <div class="gauge-readout" id="gauge-readout">Snug</div>
      <div class="gauge-detail" id="gauge-detail"></div>
    </div>
    <div class="gauge">
      <div class="gauge-label">Durability</div>
      <div class="gauge-track" style="background: linear-gradient(to right, #2a9d8f, #8ab840 35%, #f4a261 60%, #e94560 80%, #a00030);">
        <div class="gauge-pip" id="dur-pip"></div>
      </div>
      <div class="gauge-labels">
        <span>Robust</span>
        <span>Sturdy</span>
        <span>Fair</span>
        <span>Brittle</span>
      </div>
      <div class="gauge-readout" id="dur-readout">Solid</div>
      <div class="gauge-detail" id="dur-detail"></div>
    </div>
  </div>
</div>

<button id="sidebar-toggle" aria-label="Toggle settings">&#9881;</button>

<script>
'use strict';
// ============================================================
//  Constants & utilities
// ============================================================
const TAU = Math.PI * 2;
const sqrt2 = Math.SQRT2;
const sqrt3 = Math.sqrt(3);
const cvs = document.getElementById('c');
const ctx = cvs.getContext('2d');

function deg(d) { return d * Math.PI / 180; }

const OVERLAY_BOX = 260;  // unified width & height for canvas overlays
let closeRegions = [];     // {x, y, w, h, id} hit targets for overlay X buttons
let hoveredClose = null;   // id of close button currently hovered

function drawOverlayClose(bx, by, bw, checkboxId) {
  const hitW = 20, hitH = 20;
  const rx = bx + bw - hitW - 6;
  const ry = by + 4;
  closeRegions.push({ x: rx, y: ry, w: hitW, h: hitH, id: checkboxId });
  ctx.font = '13px sans-serif';
  ctx.fillStyle = hoveredClose === checkboxId ? THEME.accent : '#555';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('\u00D7', rx + hitW / 2, ry + hitH / 2);
}

function canvasMouseCoords(e) {
  const rect = cvs.getBoundingClientRect();
  return {
    x: (e.clientX - rect.left) * (cvs.width / rect.width),
    y: (e.clientY - rect.top) * (cvs.height / rect.height),
  };
}

function hitCloseRegion(mx, my) {
  for (const r of closeRegions) {
    if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) return r;
  }
  return null;
}

cvs.addEventListener('click', e => {
  const { x, y } = canvasMouseCoords(e);
  const hit = hitCloseRegion(x, y);
  if (hit) {
    document.getElementById(hit.id).checked = false;
    onInput();
  }
});

// ---- Canvas interaction: close buttons, drag, scroll zoom ----
let dragging = false, dragStartX = 0, dragStartY = 0, dragStartTilt = 0, dragStartRot = 0;

function updateSlider(id, vid, fmt, val) {
  const el = document.getElementById(id);
  val = Math.max(+el.min, Math.min(+el.max, val));
  el.value = val;
  document.getElementById(vid).textContent = fmt(+el.value);
}

cvs.addEventListener('mousemove', e => {
  if (dragging) {
    const dx = e.clientX - dragStartX;
    const dy = e.clientY - dragStartY;
    updateSlider('tilt', 'v-tilt', v => v + '\u00B0', Math.round(dragStartTilt - dy * 0.3));
    updateSlider('rotation', 'v-rotation', v => v + '\u00B0', Math.round(dragStartRot + dx * 0.5));
    syncPerspVisibility();
    onInput();
    return;
  }
  const { x, y } = canvasMouseCoords(e);
  const hit = hitCloseRegion(x, y);
  cvs.style.cursor = hit ? 'pointer' : '';
  const newHover = hit ? hit.id : null;
  if (newHover !== hoveredClose) { hoveredClose = newHover; draw(); }
});

cvs.addEventListener('mousedown', e => {
  const { x, y } = canvasMouseCoords(e);
  if (hitCloseRegion(x, y)) return;
  dragging = true;
  dragStartX = e.clientX;
  dragStartY = e.clientY;
  dragStartTilt = +document.getElementById('tilt').value;
  dragStartRot = +document.getElementById('rotation').value;
  cvs.style.cursor = 'grabbing';
  e.preventDefault();
});

window.addEventListener('mouseup', () => {
  if (dragging) { dragging = false; cvs.style.cursor = ''; }
});

// Touch drag support
cvs.addEventListener('touchstart', e => {
  if (e.touches.length === 1) {
    const t = e.touches[0];
    dragging = true;
    dragStartX = t.clientX;
    dragStartY = t.clientY;
    dragStartTilt = +document.getElementById('tilt').value;
    dragStartRot = +document.getElementById('rotation').value;
  }
}, { passive: true });

cvs.addEventListener('touchmove', e => {
  if (dragging && e.touches.length === 1) {
    const t = e.touches[0];
    const dx = t.clientX - dragStartX;
    const dy = t.clientY - dragStartY;
    updateSlider('tilt', 'v-tilt', v => v + '\u00B0', Math.round(dragStartTilt - dy * 0.3));
    updateSlider('rotation', 'v-rotation', v => v + '\u00B0', Math.round(dragStartRot + dx * 0.5));
    syncPerspVisibility();
    onInput();
  }
}, { passive: true });

cvs.addEventListener('touchend', () => { dragging = false; });

// Scroll wheel / pinch zoom
cvs.addEventListener('wheel', e => {
  e.preventDefault();
  const el = document.getElementById('size');
  const delta = e.deltaY > 0 ? -3 : 3;
  updateSlider('size', 'v-size', v => v + '%', Math.round(+el.value + delta));
  onInput();
}, { passive: false });

// ============================================================
//  Polygon geometry
// ============================================================

// Regular N-gon vertices, vertex 0 at the right (angle 0).
// rotOff rotates the whole polygon (used for down-pointing triangles).
function polyVerts(cx, cy, s, sides, rotOff) {
  const off = rotOff || 0;
  const v = [];
  for (let i = 0; i < sides; i++) {
    const a = TAU * i / sides + off;
    v.push({ x: cx + s * Math.cos(a), y: cy + s * Math.sin(a) });
  }
  return v;
}

// Convenience wrapper preserving old call sites during migration
function hexVerts(cx, cy, s) { return polyVerts(cx, cy, s, 6); }

// Axial (q, r) -> pixel centre
function hex2px(q, r, s) {
  return { x: s * 1.5 * q, y: s * sqrt3 * (r + 0.5 * q) };
}

// Hex grid sized to fill roughly n columns × n rows
function hexGrid(n) {
  const rings = Math.max(1, Math.round((n - 1) / 2));
  const cells = [];
  for (let q = -rings; q <= rings; q++)
    for (let r = Math.max(-rings, -q - rings); r <= Math.min(rings, -q + rings); r++)
      cells.push({ q, r });
  return cells;
}

// Proper 3-colouring of the hex grid (no two neighbours share a colour)
function hexColor3(q, r) { return (((q - r) % 3) + 3) % 3; }

// ---- Square grid ----
function squareGrid(n) {
  const half = Math.floor(n / 2);
  const cells = [];
  for (let row = -half; row < n - half; row++)
    for (let col = -half; col < n - half; col++)
      cells.push({ col, row });
  return cells;
}
function square2px(col, row, s) {
  const side = s * sqrt2;  // side length when circumradius = s
  return { x: side * col, y: side * row };
}
function squareColor(col, row) { return (((col + row) % 3) + 3) % 3; }

// ---- Triangle grid ----
// One triangle per (col, row). Orientation from parity: up when (col+row) even.
// Up triangles have vertex at top (rotOff = -π/2), down at bottom (rotOff = π/2).
function triGrid(n) {
  const halfR = Math.floor(n / 2);
  const halfC = n;  // roughly 2× columns for triangles to fill square-ish area
  const cells = [];
  for (let row = -halfR; row < n - halfR; row++)
    for (let col = -halfC; col < halfC; col++) {
      const up = ((col + row) & 1) === 0;
      cells.push({ col, row, up });
    }
  return cells;
}
function tri2px(col, row, up, s) {
  const x = col * s * sqrt3 / 2;
  const y = row * s * 1.5 + (up ? 0 : -s / 2);
  return { x, y };
}
function triColor(col, row) {
  return (((col + 2 * row) % 3) + 3) % 3;
}

// ============================================================
//  Modified tile outline  (the core algorithm)
//
//  At each tiling vertex V (shared by 3 tiles) the tile still
//  comes to a point at V, but the two edges meeting at V are
//  each "twisted" by theta within distance r of V.
//
//  Path at each vertex:
//
//    P_in  →  Q_in  →  V  →  Q_out  →  P_out
//
//  P_in / P_out sit on the original hex edges at distance r from V.
//  Q_in / Q_out are those points rotated by +theta around V.
//
//  The segment P_in→Q_in is a small jog (tab on one side,
//  notch on the other).  Similarly Q_out→P_out.
//  Between vertices, the boundary follows the original hex edge.
//
//  Because V is still on the boundary, there is NO void at any
//  vertex — the three tiles meet cleanly at every junction.
// ============================================================

// Each point carries a rounding tag:
//   .vtx = true   → vertex intersection point (uses vtxRadius)
//   .vtx = false   → edge/jog corner point (uses edgeRadius)
//   .smooth = true → arc interior point (skip rounding entirely)

function tileOutline(cx, cy, s, r, thetaDeg, useAngular, sides, rotOff) {
  const n = sides || 6;
  const verts = polyVerts(cx, cy, s, n, rotOff);
  if (r < 0.001 || Math.abs(thetaDeg) < 0.01)
    return verts.map(v => ({ x: v.x, y: v.y, vtx: true, side: true }));

  const theta = deg(thetaDeg);
  const pts = [];
  const push = (x, y, vtx, smooth, side) => pts.push({ x, y, vtx: !!vtx, smooth: !!smooth, side: !!side });

  for (let i = 0; i < n; i++) {
    const V  = verts[i];
    const Vp = verts[(i + n - 1) % n];
    const Vn = verts[(i + 1) % n];

    const ap = Math.atan2(Vp.y - V.y, Vp.x - V.x);
    const an = Math.atan2(Vn.y - V.y, Vn.x - V.x);

    // P_in  (edge point — transition corner, always roundable)
    push(V.x + r * Math.cos(ap), V.y + r * Math.sin(ap), false, false, true);

    // Q_in  (edge point(s) — tab jog)
    if (useAngular) {
      push(V.x + r * Math.cos(ap + theta), V.y + r * Math.sin(ap + theta), false, false);
    } else {
      const arcN = Math.max(3, Math.round(8 * Math.abs(theta) / (TAU / 3)));
      for (let j = 1; j <= arcN; j++) {
        // First and last arc points are transitions; interior points are smooth
        const isEnd = j === arcN;
        push(V.x + r * Math.cos(ap + theta * j / arcN), V.y + r * Math.sin(ap + theta * j / arcN), false, !isEnd);
      }
    }

    // V  (VERTEX intersection point)
    push(V.x, V.y, true, false);

    // Q_out  (edge point(s) — notch jog)
    if (useAngular) {
      push(V.x + r * Math.cos(an + theta), V.y + r * Math.sin(an + theta), false, false);
    } else {
      // First point is transition
      push(V.x + r * Math.cos(an + theta), V.y + r * Math.sin(an + theta), false, false);
      const arcN = Math.max(3, Math.round(8 * Math.abs(theta) / (TAU / 3)));
      for (let j = 1; j < arcN; j++) {
        push(V.x + r * Math.cos(an + theta * (1 - j / arcN)), V.y + r * Math.sin(an + theta * (1 - j / arcN)), false, true);
      }
    }

    // P_out  (edge point — transition corner, always roundable)
    push(V.x + r * Math.cos(an), V.y + r * Math.sin(an), false, false, true);
  }
  return pts;
}

// ============================================================
//  Corner rounding
//
//  Replace each sharp corner with a circular arc.
//  Each point carries a .vtx flag — vertex intersection points
//  use vtxRadius, all other corners use edgeRadius.
// ============================================================

function roundCorners(pts, edgeRadius, vtxRadius) {
  if (pts.length < 3) return pts;
  if (edgeRadius < 0.001 && vtxRadius < 0.001) return pts;

  const n = pts.length;
  const out = [];
  const ARC_SEGS = 6;

  for (let i = 0; i < n; i++) {
    const A = pts[(i - 1 + n) % n];
    const B = pts[i];
    const C = pts[(i + 1) % n];

    if (B.smooth) { out.push(B); continue; }
    const radius = B.vtx ? vtxRadius : edgeRadius;
    if (radius < 0.001) { out.push(B); continue; }

    let dxBA = A.x - B.x, dyBA = A.y - B.y;
    let dxBC = C.x - B.x, dyBC = C.y - B.y;
    const lenBA = Math.sqrt(dxBA * dxBA + dyBA * dyBA);
    const lenBC = Math.sqrt(dxBC * dxBC + dyBC * dyBC);

    if (lenBA < 0.001 || lenBC < 0.001) { out.push(B); continue; }

    dxBA /= lenBA; dyBA /= lenBA;
    dxBC /= lenBC; dyBC /= lenBC;

    const dot = dxBA * dxBC + dyBA * dyBC;
    const halfAngle = Math.acos(Math.max(-1, Math.min(1, dot))) / 2;

    if (halfAngle < 0.001 || halfAngle > Math.PI - 0.001) {
      out.push(B); continue;
    }

    const tan_ha = Math.tan(halfAngle);
    let d = radius / tan_ha;

    const maxD = Math.min(lenBA, lenBC) * 0.45;
    if (d > maxD) d = maxD;
    const actualR = d * tan_ha;

    const T1 = { x: B.x + dxBA * d, y: B.y + dyBA * d };
    const T2 = { x: B.x + dxBC * d, y: B.y + dyBC * d };

    const bisX = dxBA + dxBC, bisY = dyBA + dyBC;
    const bisLen = Math.sqrt(bisX * bisX + bisY * bisY);
    if (bisLen < 0.001) { out.push(B); continue; }
    const dist = actualR / Math.sin(halfAngle);
    const cx = B.x + (bisX / bisLen) * dist;
    const cy = B.y + (bisY / bisLen) * dist;

    const a1 = Math.atan2(T1.y - cy, T1.x - cx);
    const a2 = Math.atan2(T2.y - cy, T2.x - cx);

    let sweep = a2 - a1;
    while (sweep > Math.PI)  sweep -= TAU;
    while (sweep < -Math.PI) sweep += TAU;

    for (let j = 0; j <= ARC_SEGS; j++) {
      const a = a1 + sweep * j / ARC_SEGS;
      out.push({ x: cx + actualR * Math.cos(a), y: cy + actualR * Math.sin(a) });
    }
  }
  return out;
}

// ============================================================
//  Side smoothing
//
//  Replace straight segments between twist circles with S-curves.
//  Each side segment is split at its midpoint into two quadratic
//  beziers — first half bows outward, second half bows inward.
//  The S-curve is point-symmetric about the edge midpoint so
//  adjacent tiles' shared edges remain complementary.
// ============================================================

function smoothSides(pts, pct, cx, cy, angle) {
  // Effective amount scales with both the slider percentage and the
  // twist angle — 100% at 55° gives ~0.4, 0° always gives 0.
  const eff = pct * Math.abs(angle) * (0.4 / 55);
  if (eff < 0.001) return pts;
  const n = pts.length;
  if (n < 3) return pts;

  // Build a set of segment indices [i, i+1] that are both side points
  // (side===true for normal case, or vtx===true for the r=0 early-return case)
  const isSide = p => !!(p.side || p.vtx);
  const pairs = [];
  for (let i = 0; i < n; i++) {
    const j = (i + 1) % n;
    if (isSide(pts[i]) && isSide(pts[j])) {
      pairs.push(i);
    }
  }
  if (pairs.length === 0) return pts;

  const pairSet = new Set(pairs);
  const out = [];
  const HALF_SEGS = 12;
  // S-curve direction follows twist angle sign
  const sign = angle < 0 ? -1 : 1;
  // Fraction of segment to leave clear near each endpoint so
  // roundCorners' maxD calculation isn't constrained by our points.
  const GAP = 0.15;

  for (let i = 0; i < n; i++) {
    if (pairSet.has(i)) {
      const j = (i + 1) % n;
      const A = pts[i], B = pts[j];
      const dx = B.x - A.x, dy = B.y - A.y;
      const segLen = Math.sqrt(dx * dx + dy * dy);
      if (segLen < 0.001) { out.push(A); continue; }

      // Midpoint of the side segment
      const midX = (A.x + B.x) / 2, midY = (A.y + B.y) / 2;

      // Perpendicular — pick direction pointing away from center
      let nx = -dy, ny = dx;
      const toCx = cx - midX, toCy = cy - midY;
      if (nx * toCx + ny * toCy > 0) { nx = -nx; ny = -ny; }
      const nl = Math.sqrt(nx * nx + ny * ny);
      nx /= nl; ny /= nl;

      const disp = sign * eff * segLen;

      // S-curve: two quadratic beziers, point-symmetric about midpoint.
      // First half bows outward, second half bows inward.
      // Angle sign flips which half bows which way.
      // Control points at the quarter and three-quarter marks.
      const cp1x = (A.x + midX) / 2 + nx * disp;
      const cp1y = (A.y + midY) / 2 + ny * disp;
      const cp2x = (midX + B.x) / 2 - nx * disp;
      const cp2y = (midY + B.y) / 2 - ny * disp;

      // Emit A with its original flags, then interior bezier points
      // (skipping points too close to endpoints), then let B be
      // emitted naturally when the loop reaches its index.
      out.push(A);
      // First half: A → midpoint via cp1 (skip k=0=A, skip points in gap)
      for (let k = 1; k <= HALF_SEGS; k++) {
        const t = k / HALF_SEGS;
        const tFull = t * 0.5;  // position along full segment [0..0.5]
        if (tFull < GAP) continue;
        const u = 1 - t;
        out.push({
          x: u * u * A.x + 2 * u * t * cp1x + t * t * midX,
          y: u * u * A.y + 2 * u * t * cp1y + t * t * midY,
          smooth: true,
        });
      }
      // Second half: midpoint → B via cp2 (skip k=0=midpoint, skip k=HALF_SEGS=B, skip points in gap)
      for (let k = 1; k < HALF_SEGS; k++) {
        const t = k / HALF_SEGS;
        const tFull = 0.5 + t * 0.5;  // position along full segment [0.5..1]
        if (1 - tFull < GAP) continue;
        const u = 1 - t;
        out.push({
          x: u * u * midX + 2 * u * t * cp2x + t * t * B.x,
          y: u * u * midY + 2 * u * t * cp2y + t * t * B.y,
          smooth: true,
        });
      }
    } else {
      out.push(pts[i]);
    }
  }
  return out;
}

// ============================================================
//  Drawing helpers
// ============================================================

function tracePath(pts) {
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.closePath();
}

function darkenHex(hex, factor) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgb(${r * factor | 0},${g * factor | 0},${b * factor | 0})`;
}

// Themes: tile colors + full UI palette
const SCHEMES = [
  { name: 'Neon', colors: ['#e94560', '#2a9d8f', '#f4a261'],
    bg:'#1a1a2e', sidebar:'#16213e', canvas:'#0f3460', border:'#2a2a4e',
    accent:'#e94560', accentHover:'#c73650', label:'#bbb', muted:'#555',
    link:'#7ba4cc', overlay:'#1a1a2e', stroke:'#1a1a2e' },
  { name: 'Berry', colors: ['#7b2d8e', '#d63384', '#ffb3c6'],
    bg:'#1a0e1e', sidebar:'#241428', canvas:'#1e0a22', border:'#3a1845',
    accent:'#d63384', accentHover:'#b82870', label:'#c8a0b8', muted:'#7a4868',
    link:'#e888b8', overlay:'#1a0e1e', stroke:'#1a0e1e' },
  { name: 'Earth', colors: ['#606c38', '#bc6c25', '#dda15e'],
    bg:'#1c1a14', sidebar:'#252218', canvas:'#2a2616', border:'#3d3828',
    accent:'#dda15e', accentHover:'#c48a48', label:'#b8a888', muted:'#706848',
    link:'#c8a868', overlay:'#1c1a14', stroke:'#1c1a14' },
  { name: 'Ocean', colors: ['#1d3557', '#457b9d', '#a8dadc'],
    bg:'#0b1929', sidebar:'#0f2132', canvas:'#132e45', border:'#1d3557',
    accent:'#a8dadc', accentHover:'#8ac4c8', label:'#8ab4c4', muted:'#4a7080',
    link:'#a8dadc', overlay:'#0b1929', stroke:'#0b1929' },
  { name: 'Slate', colors: ['#495057', '#6c757d', '#adb5bd'],
    bg:'#1a1c1e', sidebar:'#212529', canvas:'#2b2e32', border:'#3a3e44',
    accent:'#adb5bd', accentHover:'#8e959c', label:'#9a9ea4', muted:'#5a5e64',
    link:'#8ca0b0', overlay:'#1a1c1e', stroke:'#1a1c1e' },
  { name: 'Synth', colors: ['#8b6cc7', '#4aada8', '#d46a94'],
    bg:'#0d0221', sidebar:'#1a0533', canvas:'#120630', border:'#3a1568',
    accent:'#ff6ec7', accentHover:'#e050a8', label:'#c0a0d8', muted:'#6a4c93',
    link:'#72c4ff', overlay:'#0d0221', stroke:'#0d0221' },
  { name: 'Ember', colors: ['#ff7043', '#ffb74d', '#e65100'],
    bg:'#1b1210', sidebar:'#261a16', canvas:'#2e1e18', border:'#4a3028',
    accent:'#ff7043', accentHover:'#e65100', label:'#c4a898', muted:'#7a5a48',
    link:'#ffab91', overlay:'#1b1210', stroke:'#1b1210' },
  { name: 'Moss', colors: ['#26a69a', '#66bb6a', '#81c784'],
    bg:'#0e1a16', sidebar:'#142420', canvas:'#1a2e28', border:'#2a4a3e',
    accent:'#66bb6a', accentHover:'#4caf50', label:'#98c4a8', muted:'#4a7a60',
    link:'#80cbc4', overlay:'#0e1a16', stroke:'#0e1a16' },
];
let THEME = SCHEMES[0];

// Shape configurations: sides, vertex valence, max twist, grid/color/layout
const SHAPES = {
  6: { sides: 6, name: 'Hexagon',  valence: 3, maxTwist: 55,
    grid: hexGrid,
    cell2px: (cell, s) => hex2px(cell.q, cell.r, s),
    cellColor: cell => hexColor3(cell.q, cell.r),
    cellRot: () => 0,
    // 3 hexes sharing vertex 0 of (0,0)
    junctionCells: () => [
      { q: 0, r: 0 }, { q: 1, r: 0 }, { q: 1, r: -1 },
    ],
    junctionVertex: s => ({ x: s, y: 0 }),
  },
  4: { sides: 4, name: 'Square', valence: 4, maxTwist: 45,
    grid: squareGrid,
    cell2px: (cell, s) => square2px(cell.col, cell.row, s),
    cellColor: cell => squareColor(cell.col, cell.row),
    cellRot: () => Math.PI / 4,
    // 4 squares sharing top-right corner of (0,0)
    junctionCells: () => [
      { col: 0, row: 0 }, { col: 1, row: 0 }, { col: 1, row: -1 }, { col: 0, row: -1 },
    ],
    junctionVertex: s => ({ x: s / sqrt2, y: -s / sqrt2 }),
  },
  3: { sides: 3, name: 'Triangle', valence: 6, maxTwist: 30,
    grid: triGrid,
    cell2px: (cell, s) => tri2px(cell.col, cell.row, cell.up, s),
    cellColor: cell => triColor(cell.col, cell.row),
    cellRot: cell => cell.up ? -Math.PI / 2 : Math.PI / 2,
    // 6 triangles sharing top vertex of up(0,0) at (0, -s)
    junctionCells: () => [
      { col: 0, row: 0, up: true },
      { col: 1, row: 0, up: false },
      { col: 1, row: -1, up: true },
      { col: 0, row: -1, up: false },
      { col: -1, row: -1, up: true },
      { col: -1, row: 0, up: false },
    ],
    junctionVertex: s => ({ x: 0, y: -s }),
  },
};
let SHAPE = SHAPES[6];

function setShape(sides) {
  SHAPE = SHAPES[sides] || SHAPES[6];
  document.getElementById('sides-' + SHAPE.sides).checked = true;
  // Clamp twist angle to new max
  const angleEl = document.getElementById('angle');
  angleEl.min = -SHAPE.maxTwist;
  angleEl.max = SHAPE.maxTwist;
  if (+angleEl.value > SHAPE.maxTwist) angleEl.value = SHAPE.maxTwist;
  if (+angleEl.value < -SHAPE.maxTwist) angleEl.value = -SHAPE.maxTwist;
  document.getElementById('v-angle').textContent = (+angleEl.value).toFixed(1) + '\u00B0';
}

function setScheme(idx) {
  const t = SCHEMES[Math.max(0, Math.min(idx, SCHEMES.length - 1))];
  THEME = t;
  const r = document.documentElement.style;
  r.setProperty('--bg', t.bg);
  r.setProperty('--sidebar', t.sidebar);
  r.setProperty('--canvas', t.canvas);
  r.setProperty('--border', t.border);
  r.setProperty('--accent', t.accent);
  r.setProperty('--accent-hover', t.accentHover);
  r.setProperty('--label', t.label);
  r.setProperty('--muted', t.muted);
  r.setProperty('--link', t.link);
  r.setProperty('--overlay-bg', t.overlay);
  r.setProperty('--tile-stroke', t.stroke);
}

// ============================================================
//  Interlock gauge — physics-based model
//
//  Three factors combine into the interlock score:
//
//  1. EFFECTIVE TAB DEPTH  (d_eff)
//     Raw depth = r * sin|θ|  (perpendicular jog displacement).
//     Edge rounding at the jog peak (Q point) shaves this down.
//     The jog-peak corner angle is  α = 90° − |θ|/2.
//     Inscribing a round of radius ρ pulls the peak back by
//       Δd = ρ × (1/sin(α/2) − 1)
//
//  2. SELF-LOCKING  (friction on the jog face)
//     The jog-face normal is at |θ|/2 from the edge direction.
//     A sliding tile must overcome friction to ride up the face:
//       self-locking ⟺  tan(|θ|/2) ≤ μ
//     For wood-on-wood μ ≈ 0.25–0.5.  Beyond the lock angle
//     the face becomes a ramp the tile can climb, and the
//     advantage drops as μ / tan(|θ|/2).
//
//  3. JOG CONTACT LENGTH  (friction surface)
//     Face chord = 2r sin(|θ|/2).  Vertex rounding shortens
//     the Q→V segment (V is a 60° point, so ρ_vtx eats 1.73×
//     its value off each radial arm), reducing usable contact.
// ============================================================

function updateGauge(p) {
  const s        = p.size;
  const sideLen  = 2 * s * Math.sin(Math.PI / SHAPE.sides);
  const r        = p.radius * sideLen;
  const absDeg   = Math.abs(p.angle);
  const absRad   = deg(absDeg);
  const rhoEdge  = p.roundEdge * sideLen;
  const rhoVtx   = p.roundVtx  * sideLen;
  const MU       = 0.35;                // wood-on-wood, moderate
  const thick    = p.thickness;          // mm (physical)
  const exportMm = p.exportSize;         // mm — user's desired side length
  const scaleMm  = exportMm / sideLen;   // px → mm at export side

  // ---- 1. Effective tab depth (in mm at export scale) ----
  const rawDepth = r * Math.sin(absRad);

  // Jog-peak corner angle α = π/2 − |θ|/2
  const alpha     = Math.PI / 2 - absRad / 2;
  const sinHalfA  = Math.sin(Math.max(alpha / 2, 0.05));   // guard div/0
  const edgeRoundLoss = rhoEdge * (1 / sinHalfA - 1);

  const effectiveDepth   = Math.max(0, rawDepth - edgeRoundLoss);
  const effectiveDepthMm = effectiveDepth * scaleMm;

  // Tab presence gate: is there a meaningful tab at all?
  // Saturates quickly — even a 1mm tab is "present".
  const depthPresence = effectiveDepthMm < 0.001 ? 0
    : Math.min(1, 1 - Math.exp(-3 * effectiveDepthMm));

  // Mechanical block: how much of a physical wall is this tab?
  // A 5mm tab is a serious wall regardless of material.
  // Linear ramp — proportional to absolute depth.
  const mechanicalBlock = Math.min(1, effectiveDepthMm / 5.0);

  // ---- 2. Self-locking factor ----
  // Face normal angle from edge direction = |θ|/2.
  // Below friction angle: tab face grips — tile can't slide free.
  // Above: force needed grows with angle, but there's still mechanical
  // interference (the tab is a physical wall, not just friction).
  // Model: self-lock contributes friction holding; even without it,
  // the tab blocks lateral motion as long as depth > 0.
  const tanHalf  = Math.tan(absRad / 2);
  const lockAngleRad = Math.atan(MU);
  // Friction bonus: 1.0 when self-locking, tapering above friction angle
  // but never below 0.3 — mechanical interference still resists motion.
  //
  // Angular vs arc jogs: angular jogs have a single flat face with normal
  // at |θ|/2.  Arc jogs spread the contact over normals from 0 to |θ|,
  // so portions of the arc self-lock even when the peak angle doesn't.
  // Model: arc jogs use the average normal angle |θ|/4 instead of |θ|/2.
  const faceAngle = p.angular ? absRad / 2 : absRad / 4;
  const tanFace   = Math.tan(faceAngle);
  const frictionBonus = absRad < 0.01 ? 0
    : tanFace <= MU ? 1.0
    : Math.max(0.3, MU / tanFace);

  // ---- 3. Contact-area factor ----
  // Jog face length (in mm at export scale)
  // Angular jogs: flat face = chord = 2r sin(|θ|/2)
  // Arc jogs: curved face = arc length = r × |θ| (longer contact surface)
  const jogFace    = p.angular ? 2 * r * Math.sin(absRad / 2) : r * absRad;
  const jogChordMm = jogFace * scaleMm;
  // Contact area = face length × thickness (the jog face at Q is independent
  // of vertex rounding — rounding at V doesn't shrink the face at Q).
  const contactArea    = jogChordMm * thick;
  const refArea        = 2.0 * 2.0;  // mm² — meaningful engagement surface
  const contactFactor  = Math.min(1, contactArea / refArea);

  // ---- 4. Vertex-rounding contact reduction ----
  // Vertex rounding shortens the Q→V arm by ρ_vtx / tan(half exterior angle).
  // This reduces the friction contact surface near V, but does NOT affect
  // tab depth or the mechanical block (the jog at Q is far from V).
  // Only the contact-area factor is penalized.
  const vtxEat  = rhoVtx / Math.tan(Math.PI / SHAPE.sides);
  const armLeft = Math.max(0, r - vtxEat);
  const armFrac = r > 0.001 ? armLeft / r : 0;

  // ---- Composite score (0 – 1) ----
  // depthPresence gates everything (no tab = no interlock).
  // armFrac only reduces friction contact, not tab depth or mechanical block.
  //
  // Hybrid blend of two combination strategies:
  //   Shallow tabs (low mechanicalBlock): weighted average — friction matters
  //   proportionally alongside the small physical wall.
  //   Deep tabs (high mechanicalBlock): complementary — either mechanism
  //   alone suffices (a 5mm wall is seized regardless of friction).
  // The blend parameter is mechanicalBlock itself, giving a smooth transition.
  const frictionHold = frictionBonus * contactFactor * armFrac;
  const weightedAvg  = 0.4 * mechanicalBlock + 0.6 * frictionHold;
  const complement   = 1 - (1 - mechanicalBlock) * (1 - frictionHold);
  const blend        = mechanicalBlock;
  const combined     = weightedAvg * (1 - blend) + complement * blend;
  const rawScore     = depthPresence * combined;
  const pct      = Math.min(1, Math.max(0, rawScore));

  // ---- Update DOM ----
  document.getElementById('gauge-pip').style.left = (pct * 100) + '%';

  const labels = [
    [0.00, 'Free-sliding', '#888'],
    [0.03, 'Loose',        '#2a9d8f'],
    [0.12, 'Gentle',       '#4aad7f'],
    [0.22, 'Snug',         '#8ab840'],
    [0.35, 'Firm',         '#c8a030'],
    [0.50, 'Stiff',        '#e08030'],
    [0.70, 'Tight',        '#e06040'],
    [0.85, 'Locked',       '#d03050'],
    [0.95, 'Seized',       '#a00030'],
  ];
  let label = labels[0][1], color = labels[0][2];
  for (const [thresh, l, c] of labels) {
    if (pct >= thresh) { label = l; color = c; }
  }

  const readout = document.getElementById('gauge-readout');
  readout.textContent = label;
  readout.style.color = color;

  // Detail line — physical dims at 50 mm export side
  const mmDepth   = effectiveDepthMm.toFixed(2);
  const mmFace    = jogChordMm.toFixed(1);
  const lockAngleDeg = (lockAngleRad * 180 / Math.PI).toFixed(0);
  const lockStr   = tanFace <= MU ? 'self-locking' : 'slides (past ' + lockAngleDeg + '\u00B0)';
  document.getElementById('gauge-detail').textContent =
    `tab ${mmDepth}mm | face ${mmFace}mm \u00D7 ${thick.toFixed(1)}mm | ${lockStr}  (\u00B5=${MU}, ${exportMm.toFixed(1)}mm side)`;

  // Polygon dimensions: side length, flat-to-flat (apothem × 2), point-to-point (circumradius × 2)
  const circumR = exportMm / (2 * Math.sin(Math.PI / SHAPE.sides));
  const dimSide = exportMm.toFixed(1);
  const ftf = (2 * circumR * Math.cos(Math.PI / SHAPE.sides)).toFixed(1);
  const ptp = (circumR * 2).toFixed(1);
  document.getElementById('hex-dims').textContent =
    `side ${dimSide}mm | ${ftf}mm flat\u2011to\u2011flat | ${ptp}mm vertex\u2011to\u2011vertex`;

  // ---- Durability gauge ----
  // Two failure modes:
  //   1. Tab snap — the tab (protrusion at each jog) breaks off.
  //   2. Body snap — the tile interior becomes too thin between notches.
  //
  // Tab: cantilever beam, bending at base. Kt from Peterson fillet model.
  // Body: apothem minus notch depth gives remaining waist width.
  //   Triangles are especially vulnerable (apothem ≈ 0.29 × side).

  const effectivePresence = depthPresence;

  // -- Tab strength --
  const rhoEdgeMm = rhoEdge * scaleMm;
  const KT_MAX    = 4.0;
  const Kt = rhoEdgeMm > 0.01
    ? Math.min(KT_MAX, 1 + 2 * Math.sqrt(effectiveDepthMm / rhoEdgeMm))
    : KT_MAX;

  const bendStrength = thick * thick / Math.cos(absRad / 2);
  const bendFactor   = 1 - Math.exp(-bendStrength / (3.0 * Kt));

  const minCross   = Math.min(jogChordMm, thick);
  const sizeFactor = 1 - Math.exp(-minCross / 2.0);

  const tabDurability = 0.6 * bendFactor + 0.4 * sizeFactor;
  const tabScore      = 1.0 - effectivePresence * (1.0 - tabDurability);

  // -- Body strength (inner waist) --
  // Apothem = perpendicular distance from center to edge midpoint.
  // Notch depth eats inward from the edge. When depth ≈ apothem the
  // tile is nearly bisected and will snap across the middle.
  const apothemMm = exportMm / (2 * Math.tan(Math.PI / SHAPE.sides));
  const waistMm   = Math.max(0, apothemMm - effectiveDepthMm);
  const minBody   = Math.min(waistMm, thick);
  const bodyScore = minBody < 0.01 ? 0 : Math.min(1, 1 - Math.exp(-minBody / 2.0));

  // -- Edge wear (handling attrition) --
  // Sharper vertex angles wear down faster with use. Rounding mitigates.
  // Triangle 60° tips are fragile; hex 120° corners barely affected.
  const vtxAngle     = (SHAPE.sides - 2) * Math.PI / SHAPE.sides;
  const sharpness    = 1 - vtxAngle / Math.PI;  // tri 0.67, sq 0.5, hex 0.33
  const rhoVtxMm     = rhoVtx * scaleMm;
  const roundProtect = 1 - Math.exp(-(rhoEdgeMm + rhoVtxMm) / 0.8);
  const wearFactor   = 1 - sharpness * (1 - roundProtect) * 0.35;

  // Overall durability: weakest link, then wear
  const durability = Math.min(tabScore, bodyScore) * wearFactor;
  const durPct     = Math.min(1, Math.max(0, durability));

  document.getElementById('dur-pip').style.left = ((1 - durPct) * 100) + '%';

  const durLabels = [
    [0.00, 'Brittle',  '#a00030'],
    [0.10, 'Fragile',  '#d03050'],
    [0.20, 'Delicate', '#e08030'],
    [0.35, 'Fair',     '#c8a030'],
    [0.50, 'Solid',    '#8ab840'],
    [0.65, 'Sturdy',   '#4aad7f'],
    [0.80, 'Robust',   '#2a9d8f'],
    [0.95, 'Ironclad', '#1a8a7a'],
  ];
  let durLabel = durLabels[0][1], durColor = durLabels[0][2];
  for (const [thresh, l, c] of durLabels) {
    if (durPct >= thresh) { durLabel = l; durColor = c; }
  }
  const durReadout = document.getElementById('dur-readout');
  durReadout.textContent = durLabel;
  durReadout.style.color = durColor;

  const ktStr = Kt < KT_MAX ? `Kt=${Kt.toFixed(1)}` : `Kt=${KT_MAX.toFixed(0)} (no fillet)`;
  const waistStr = waistMm < apothemMm * 0.99 ? ` | waist ${waistMm.toFixed(1)}mm` : '';
  document.getElementById('dur-detail').textContent =
    `base ${jogChordMm.toFixed(1)}mm \u00D7 ${thick.toFixed(1)}mm | ${ktStr}${waistStr}`;
}

// ============================================================
//  Main draw
// ============================================================

function getP() {
  return {
    angle:   +document.getElementById('angle').value,
    radius:  +document.getElementById('radius').value,
    size:    +document.getElementById('size').value,
    gridR:   +document.getElementById('grid').value,
    explode: +document.getElementById('explode').value / 100,
    roundEdge: +document.getElementById('round-edge').value,
    roundVtx:  +document.getElementById('round-vtx').value,
    sideSmooth:+document.getElementById('side-smooth').value / 100,
    thickness: +document.getElementById('thickness').value,
    tilt:    +document.getElementById('tilt').value,
    perspective: +document.getElementById('perspective').value,
    rotation: +document.getElementById('rotation').value,
    angular:     document.getElementById('joint-angular').checked,
    showOrig:    document.getElementById('show-original').checked,
    showCirc:    document.getElementById('show-circles').checked,
    showSingle:  document.getElementById('show-single').checked,
    showJunction:document.getElementById('show-junction').checked,
    showStats:   document.getElementById('show-stats').checked,
    scheme:    +document.getElementById('scheme').value,
    exportSize:+document.getElementById('export-size').value,
  };
}

// ---- Animated parameter interpolation ----
// Numeric params lerp toward target over ~100ms (exponential ease-out).
const ANIM_KEYS = ['angle','radius','size','explode','roundEdge','roundVtx',
  'sideSmooth','thickness','exportSize','tilt','perspective','rotation'];
let animP = null;   // current animated state
let animRaf = null;  // pending rAF id

function lerpP(cur, tgt) {
  const LERP = 0.28;  // per frame at 60fps → ~95% in 100ms
  let moving = false;
  for (const k of ANIM_KEYS) {
    const d = tgt[k] - cur[k];
    if (Math.abs(d) > 0.0001) {
      cur[k] += d * LERP;
      moving = true;
    } else {
      cur[k] = tgt[k];
    }
  }
  // Discrete values snap instantly
  cur.gridR = tgt.gridR;
  cur.angular = tgt.angular;
  cur.showOrig = tgt.showOrig;
  cur.showCirc = tgt.showCirc;
  cur.showSingle = tgt.showSingle;
  cur.showJunction = tgt.showJunction;
  cur.showStats = tgt.showStats;
  cur.scheme = tgt.scheme;
  return moving;
}

function animLoop() {
  animRaf = null;
  const tgt = getP();
  if (!animP) animP = { ...tgt };
  const moving = lerpP(animP, tgt);
  drawWithP(animP);
  const shapeStillFading = shapeFadeStart > 0 && performance.now() - shapeFadeStart < SHAPE_FADE_DUR;
  if (moving || cellFades.size > 0 || shapeStillFading) animRaf = requestAnimationFrame(animLoop);
}

function startAnim() {
  if (!animRaf) animRaf = requestAnimationFrame(animLoop);
}

// ---- Cell fade tracking: smooth opacity for appearing/disappearing tiles ----
const FADE_DUR = 300; // ms
const cellFades = new Map();  // cellKey → { born: timestamp, dying: timestamp|null }
let prevCellKeys = new Set();
let prevShapeSides = 0;

function cellKeyOf(c) {
  return c.q !== undefined ? `${c.q},${c.r}` : c.up !== undefined ? `${c.col},${c.row},${c.up}` : `${c.col},${c.row}`;
}

function updateCellFades(cells, shapeSides) {
  const now = performance.now();
  const curKeys = new Set(cells.map(cellKeyOf));

  // Shape changed — reset everything, no fade
  if (shapeSides !== prevShapeSides) {
    cellFades.clear();
    prevCellKeys = curKeys;
    prevShapeSides = shapeSides;
    return;
  }

  // New cells: start fading in
  for (const k of curKeys) {
    if (!prevCellKeys.has(k)) {
      cellFades.set(k, { born: now, dying: null });
    } else if (cellFades.has(k) && cellFades.get(k).dying) {
      // Was dying, now back — restart fade-in
      cellFades.set(k, { born: now, dying: null });
    }
  }

  // Removed cells: mark as dying (they'll be rendered as ghost tiles)
  for (const k of prevCellKeys) {
    if (!curKeys.has(k)) {
      const existing = cellFades.get(k);
      if (!existing || !existing.dying) {
        cellFades.set(k, { born: existing ? existing.born : 0, dying: now });
      }
    }
  }

  // Clean up fully faded-out entries
  for (const [k, f] of cellFades) {
    if (f.dying && now - f.dying > FADE_DUR) cellFades.delete(k);
    else if (!f.dying && now - f.born > FADE_DUR) cellFades.delete(k); // fully visible
  }

  prevCellKeys = curKeys;
  prevShapeSides = shapeSides;
}

function getCellOpacity(cell) {
  const k = cellKeyOf(cell);
  const f = cellFades.get(k);
  if (!f) return 1;
  const now = performance.now();
  if (f.dying) return Math.max(0, 1 - (now - f.dying) / FADE_DUR);
  return Math.min(1, (now - f.born) / FADE_DUR);
}

// ---- Shape crossfade: snapshot old frame, blend with new ----
const snapCvs = document.createElement('canvas');
const snapCtx = snapCvs.getContext('2d');
let shapeFadeStart = 0;
let shapeFadePrev = 0;
const SHAPE_FADE_DUR = 350; // ms

function drawWithP(p) {
  closeRegions = [];
  const tilt = p.tilt;
  const tiltRad = tilt * Math.PI / 180;
  document.getElementById('stats-overlay').style.display = p.showStats ? '' : 'none';
  updateGauge(p);

  // Detect shape change — snapshot current canvas before clearing
  if (prevShapeSides && SHAPE.sides !== shapeFadePrev) {
    snapCvs.width = cvs.width;
    snapCvs.height = cvs.height;
    snapCtx.drawImage(cvs, 0, 0);
    shapeFadeStart = performance.now();
  }
  shapeFadePrev = SHAPE.sides;

  ctx.clearRect(0, 0, cvs.width, cvs.height);

  // Draw old snapshot fading out
  const fadeElapsed = performance.now() - shapeFadeStart;
  const shapeFading = shapeFadeStart > 0 && fadeElapsed < SHAPE_FADE_DUR;
  if (shapeFading) {
    ctx.save();
    ctx.globalAlpha = Math.max(0, 1 - fadeElapsed / SHAPE_FADE_DUR);
    ctx.drawImage(snapCvs, 0, 0);
    ctx.restore();
  }

  const ox = cvs.width / 2;
  const oy = cvs.height / 2;
  const s = p.size;
  const sideLen = 2 * s * Math.sin(Math.PI / SHAPE.sides);
  const r = p.radius * sideLen;
  const cosTilt = Math.cos(tiltRad);
  const sinTilt = Math.sin(tiltRad);
  const thickPx = p.thickness * sideLen / p.exportSize;
  const extH = thickPx * sinTilt;
  const persp = p.perspective;
  // 1% → ~5× canvas height (nearly flat), 70% → ~0.6× (strong perspective)
  const focalDist = cvs.height * (0.4 + 4.6 * Math.pow(1 - persp / 70, 2));

  // Project a top-face point with perspective + Y compression
  // Clamp scale to avoid singularity when points approach/pass the focal plane
  const perspScale = z => {
    const denom = focalDist + z;
    return denom > focalDist * 0.05 ? focalDist / denom : focalDist / (focalDist * 0.05);
  };

  const proj = tilt > 0
    ? pt => {
        const yRel = pt.y - oy;
        const z = -yRel * sinTilt;
        const sc = perspScale(z);
        return { x: ox + (pt.x - ox) * sc, y: oy + yRel * cosTilt * sc };
      }
    : pt => pt;

  // Project a bottom-face point (offset by tile thickness into the table)
  const projBot = pt => {
    const yRel = pt.y - oy;
    const z = -yRel * sinTilt + thickPx * cosTilt;
    const sc = perspScale(z);
    return { x: ox + (pt.x - ox) * sc, y: oy + (yRel * cosTilt + thickPx * sinTilt) * sc };
  };

  // Table rotation (rotate entire grid around canvas center)
  const rotRad = (p.rotation || 0) * Math.PI / 180;
  const cosRot = Math.cos(rotRad), sinRot = Math.sin(rotRad);
  const rotPt = rotRad === 0 ? (x, y) => ({ x, y }) : (x, y) => {
    const dx = x - ox, dy = y - oy;
    return { x: ox + dx * cosRot - dy * sinRot, y: oy + dx * sinRot + dy * cosRot };
  };

  // Build tile data with fade for grid size transitions
  const cells = SHAPE.grid(Math.round(p.gridR));
  updateCellFades(cells, SHAPE.sides);

  // Collect current cells + dying ghost cells
  const allCells = [...cells];
  const dyingKeys = new Set(cells.map(cellKeyOf));
  for (const [k, f] of cellFades) {
    if (f.dying && !dyingKeys.has(k)) {
      // Parse key back to cell — reconstruct from the key format
      const parts = k.split(',');
      if (SHAPE.sides === 6) allCells.push({ q: +parts[0], r: +parts[1] });
      else if (SHAPE.sides === 3) allCells.push({ col: +parts[0], row: +parts[1], up: parts[2] === 'true' });
      else allCells.push({ col: +parts[0], row: +parts[1] });
    }
  }

  const tileData = allCells.map(cell => {
    const { x: px, y: py } = SHAPE.cell2px(cell, s);
    const rawCx = ox + px * (1 + p.explode);
    const rawCy = oy + py * (1 + p.explode);
    const { x: cx, y: cy } = rotPt(rawCx, rawCy);
    const rot = SHAPE.cellRot(cell) + rotRad;
    let outline = tileOutline(cx, cy, s, r, p.angle, p.angular, SHAPE.sides, rot);
    outline = smoothSides(outline, p.sideSmooth, cx, cy, p.angle);
    if (p.roundEdge > 0 || p.roundVtx > 0) outline = roundCorners(outline, p.roundEdge * sideLen, p.roundVtx * sideLen);
    const cellFade = getCellOpacity(cell);
    const shapeFade = shapeFading ? Math.min(1, fadeElapsed / SHAPE_FADE_DUR) : 1;
    return { cell, cx, cy, outline, ci: SHAPE.cellColor(cell), rot, fade: cellFade * shapeFade };
  });
  if (tilt > 0) tileData.sort((a, b) => a.cy - b.cy);

  // Pre-project all tile outlines
  for (const td of tileData) td.top = td.outline.map(proj);

  // ---- Shadow pass: soft drop shadow beneath tiles ----
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,0.4)';
  ctx.shadowBlur = 20;
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 8;
  ctx.fillStyle = THEME.canvas;
  for (const td of tileData) {
    ctx.globalAlpha = td.fade;
    tracePath(td.top);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.restore();

  // ---- Pass 1: side walls (below table surface) ----
  if (tilt > 0 && extH > 0.5) {
    for (const td of tileData) {
      const sideColor = darkenHex(THEME.colors[td.ci], 0.4);
      const edgeColor = darkenHex(THEME.colors[td.ci], 0.55);
      ctx.globalAlpha = td.fade;
      for (let i = 0; i < td.top.length; i++) {
        const j = (i + 1) % td.top.length;
        // Outward normal from original (un-projected) outline (CW winding)
        const o0 = td.outline[i], o1 = td.outline[j];
        const odx = o1.x - o0.x, ody = o1.y - o0.y;
        const outNy = -odx;
        if (outNy <= 0) continue; // skip back-facing edges
        const t0 = td.top[i], t1 = td.top[j];
        const b0 = projBot(o0), b1 = projBot(o1);
        ctx.beginPath();
        ctx.moveTo(t0.x, t0.y);
        ctx.lineTo(t1.x, t1.y);
        ctx.lineTo(b1.x, b1.y);
        ctx.lineTo(b0.x, b0.y);
        ctx.closePath();
        // Shade by facing angle
        const outNx = ody;
        const len = Math.sqrt(outNx * outNx + outNy * outNy);
        const facing = outNy / len;
        ctx.fillStyle = facing > 0.7 ? sideColor : edgeColor;
        ctx.fill();
        ctx.strokeStyle = THEME.stroke;
        ctx.lineWidth = 0.5;
        ctx.stroke();
      }
    }
    ctx.globalAlpha = 1;
  }

  // ---- Pass 2: top faces (table surface, always above side walls) ----
  for (const td of tileData) {
    // Top face
    tracePath(td.top);
    ctx.fillStyle = THEME.colors[td.ci];
    ctx.globalAlpha = 0.75 * td.fade;
    ctx.fill();

    ctx.globalAlpha = td.fade;
    tracePath(td.top);
    ctx.strokeStyle = THEME.stroke;
    ctx.lineWidth = 1.4;
    ctx.stroke();

    // Optional: original polygon outline
    if (p.showOrig) {
      const origProj = polyVerts(td.cx, td.cy, s, SHAPE.sides, td.rot).map(proj);
      tracePath(origProj);
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 0.8;
      ctx.setLineDash([3, 3]);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Optional: twist circles at vertices
    if (p.showCirc) {
      polyVerts(td.cx, td.cy, s, SHAPE.sides, td.rot).forEach(v => {
        const pv = proj(v);
        const vSc = tilt > 0 ? focalDist / (focalDist - (v.y - oy) * sinTilt) : 1;
        ctx.beginPath();
        ctx.ellipse(pv.x, pv.y, r * vSc, r * cosTilt * vSc, 0, 0, TAU);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 0.6;
        ctx.stroke();
      });
    }
  }
  ctx.globalAlpha = 1;

  // ---- Inset: isolated single tile ----
  if (p.showSingle) drawSingleTile(p);

  // ---- Inset: tile junction detail ----
  if (p.showJunction) drawJunction(p);
}

// ============================================================
//  Single tile inset (top-right corner)
// ============================================================

function drawSingleTile(p) {
  const pad = 16;
  const bw = OVERLAY_BOX, bh = OVERLAY_BOX;
  const bx = cvs.width - bw - 12;
  const by = 12;
  const s = Math.min(p.size * 1.4, (bw - pad * 2) / 2.3);
  const sl = 2 * s * Math.sin(Math.PI / SHAPE.sides);
  const r = p.radius * sl;
  const cx = bx + bw / 2;
  const cy = by + bh / 2 + 10;

  // Background box (opaque, rounded) with subtle shadow
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,0.25)';
  ctx.shadowBlur = 12;
  ctx.shadowOffsetY = 4;
  ctx.fillStyle = THEME.overlay;
  ctx.beginPath();
  ctx.roundRect(bx, by, bw, bh, 10);
  ctx.fill();
  ctx.restore();
  ctx.strokeStyle = THEME.border;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(bx, by, bw, bh, 10);
  ctx.stroke();
  drawOverlayClose(bx, by, bw, 'show-single');

  // Label
  ctx.fillStyle = '#666';
  ctx.font = '11px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Single Tile', cx, by + 14);

  // Dashed original polygon
  tracePath(polyVerts(cx, cy, s, SHAPE.sides));
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 0.7;
  ctx.setLineDash([3, 3]);
  ctx.stroke();
  ctx.setLineDash([]);

  // Twist circles
  polyVerts(cx, cy, s, SHAPE.sides).forEach(v => {
    ctx.beginPath();
    ctx.arc(v.x, v.y, r, 0, TAU);
    ctx.strokeStyle = 'rgba(233,69,96,0.25)';
    ctx.lineWidth = 0.5;
    ctx.stroke();
  });

  // Modified outline
  let outline = tileOutline(cx, cy, s, r, p.angle, p.angular, SHAPE.sides);
  outline = smoothSides(outline, p.sideSmooth, cx, cy, p.angle);
  if (p.roundEdge > 0 || p.roundVtx > 0) outline = roundCorners(outline, p.roundEdge * sl, p.roundVtx * sl);
  tracePath(outline);
  ctx.fillStyle = 'rgba(233,69,96,0.2)';
  ctx.fill();
  tracePath(outline);
  ctx.strokeStyle = '#e94560';
  ctx.lineWidth = 1.8;
  ctx.stroke();

  // Dot the tab / notch jogs for clarity
  if (Math.abs(p.angle) > 0.5) {
    const theta = deg(p.angle);
    const n = SHAPE.sides;
    const verts = polyVerts(cx, cy, s, n);
    for (let i = 0; i < n; i++) {
      const V = verts[i];
      const Vp = verts[(i + n - 1) % n];
      const Vn = verts[(i + 1) % n];
      const ap = Math.atan2(Vp.y - V.y, Vp.x - V.x);
      const an = Math.atan2(Vn.y - V.y, Vn.x - V.x);

      // Tab dot (green)
      const t1 = ap + theta / 2;
      ctx.beginPath();
      ctx.arc(V.x + r * Math.cos(t1), V.y + r * Math.sin(t1), 2.5, 0, TAU);
      ctx.fillStyle = '#2a9d8f';
      ctx.fill();

      // Notch dot (orange)
      const t2 = an + theta / 2;
      ctx.beginPath();
      ctx.arc(V.x + r * Math.cos(t2), V.y + r * Math.sin(t2), 2.5, 0, TAU);
      ctx.fillStyle = '#f4a261';
      ctx.fill();
    }
    // Legend
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#2a9d8f';
    ctx.fillText('\u25CF tab', bx + 10, by + bh - 22);
    ctx.fillStyle = '#f4a261';
    ctx.fillText('\u25CF notch', bx + 10, by + bh - 10);
  }
}

// ============================================================
//  Tile junction inset (bottom-right corner)
// ============================================================

function drawJunction(p) {
  const pad = 14;
  const bw = OVERLAY_BOX, bh = OVERLAY_BOX;
  const bx = cvs.width - bw - 12;
  const by = cvs.height - bh - 12;
  // More tiles at a vertex → need more zoom-out
  const scaleFactor = SHAPE.valence <= 3 ? 4.0 : SHAPE.valence <= 4 ? 3.2 : 2.4;
  const s = Math.min(p.size * scaleFactor, (bw - pad * 2) / 1.44);
  const sl = 2 * s * Math.sin(Math.PI / SHAPE.sides);
  const r = p.radius * sl;
  const cx = bx + bw / 2;
  const cy = by + bh / 2;

  // Background box (opaque, rounded) with subtle shadow
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,0.25)';
  ctx.shadowBlur = 12;
  ctx.shadowOffsetY = 4;
  ctx.fillStyle = THEME.overlay;
  ctx.beginPath();
  ctx.roundRect(bx, by, bw, bh, 10);
  ctx.fill();
  ctx.restore();
  ctx.strokeStyle = THEME.border;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(bx, by, bw, bh, 10);
  ctx.stroke();
  drawOverlayClose(bx, by, bw, 'show-junction');

  // Label
  ctx.fillStyle = '#666';
  ctx.font = '11px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Tile Junction', cx, by + 14);

  // Get junction tiles and shared vertex from shape config
  const jCells = SHAPE.junctionCells();
  const sharedVtx = SHAPE.junctionVertex(s);

  // Offset to place the shared vertex at the center of the inset box
  const offX = cx - sharedVtx.x;
  const offY = cy - sharedVtx.y;

  // Clip to the box
  ctx.save();
  ctx.beginPath();
  ctx.roundRect(bx, by + 20, bw, bh - 20, [0, 0, 10, 10]);
  ctx.clip();

  jCells.forEach((cell, i) => {
    const { x: px, y: py } = SHAPE.cell2px(cell, s);
    const tcx = offX + px;
    const tcy = offY + py;
    const rot = SHAPE.cellRot(cell);
    let outline = tileOutline(tcx, tcy, s, r, p.angle, p.angular, SHAPE.sides, rot);
    outline = smoothSides(outline, p.sideSmooth, tcx, tcy, p.angle);
    if (p.roundEdge > 0 || p.roundVtx > 0) outline = roundCorners(outline, p.roundEdge * sl, p.roundVtx * sl);

    tracePath(outline);
    ctx.fillStyle = THEME.colors[SHAPE.cellColor(cell)];
    ctx.globalAlpha = 0.7;
    ctx.fill();
    ctx.globalAlpha = 1;

    tracePath(outline);
    ctx.strokeStyle = THEME.stroke;
    ctx.lineWidth = 1.6;
    ctx.stroke();

    // Dashed original polygon
    tracePath(polyVerts(tcx, tcy, s, SHAPE.sides, rot));
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 0.6;
    ctx.setLineDash([2, 2]);
    ctx.stroke();
    ctx.setLineDash([]);
  });

  // Draw twist circle at the shared vertex (centered in box)
  const svx = cx;
  const svy = cy;
  ctx.beginPath();
  ctx.arc(svx, svy, r, 0, TAU);
  ctx.strokeStyle = 'rgba(255,255,255,0.35)';
  ctx.lineWidth = 1;
  ctx.setLineDash([2, 2]);
  ctx.stroke();
  ctx.setLineDash([]);

  // Show original vs rotated edge directions at the shared vertex
  if (Math.abs(p.angle) > 0.5) {
    const theta = deg(p.angle);
    // Edges radiate at equal intervals: TAU / valence
    for (let i = 0; i < SHAPE.valence; i++) {
      const ea = TAU * i / SHAPE.valence;
      // Original edge (dim)
      ctx.beginPath();
      ctx.moveTo(svx, svy);
      ctx.lineTo(svx + r * 1.15 * Math.cos(ea), svy + r * 1.15 * Math.sin(ea));
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 2]);
      ctx.stroke();
      // Rotated edge (bright)
      ctx.beginPath();
      ctx.moveTo(svx, svy);
      ctx.lineTo(svx + r * Math.cos(ea + theta), svy + r * Math.sin(ea + theta));
      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.lineWidth = 1.2;
      ctx.setLineDash([]);
      ctx.stroke();
    }
  }

  ctx.restore();
}

// ============================================================
//  SVG export
// ============================================================

function downloadSVG(svgString, filename) {
  const blob = new Blob([svgString], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

document.getElementById('export-btn').addEventListener('click', () => {
  const p = getP();
  const sl = p.exportSize;               // mm side length from input
  const s = sl / (2 * Math.sin(Math.PI / SHAPE.sides));  // circumradius in mm
  const r = p.radius * sl;
  let pts = tileOutline(0, 0, s, r, p.angle, p.angular, SHAPE.sides);
  pts = smoothSides(pts, p.sideSmooth, 0, 0, p.angle);
  if (p.roundEdge > 0 || p.roundVtx > 0) pts = roundCorners(pts, p.roundEdge * sl, p.roundVtx * sl);

  // Flip Y so SVG matches standard orientation
  const fp = pts.map(pt => ({ x: pt.x, y: -pt.y }));

  const xs = fp.map(pt => pt.x);
  const ys = fp.map(pt => pt.y);
  const mx = Math.min(...xs) - 1, my = Math.min(...ys) - 1;
  const Mx = Math.max(...xs) + 1, My = Math.max(...ys) + 1;

  const d = fp.map((pt, i) =>
    (i === 0 ? 'M' : 'L') + pt.x.toFixed(4) + ' ' + pt.y.toFixed(4)
  ).join(' ') + ' Z';

  const svg =
`<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="${mx} ${my} ${Mx - mx} ${My - my}"
     width="${(Mx - mx).toFixed(2)}mm" height="${(My - my).toFixed(2)}mm">
  <path d="${d}" fill="none" stroke="black" stroke-width="0.1"/>
</svg>`;

  const sn = SHAPE.name.toLowerCase();
  const jt = p.angular ? 'ang' : 'arc';
  const ss1 = p.sideSmooth > 0.001 ? `-ss${(p.sideSmooth * 100).toFixed(0)}` : '';
  downloadSVG(svg, `${sn}-${p.angle}deg-r${(p.radius * 100).toFixed(0)}-re${(p.roundEdge * 1000).toFixed(0)}-rv${(p.roundVtx * 1000).toFixed(0)}${ss1}-${p.exportSize}mm-${jt}.svg`);
});

// Grid SVG export — all tiles in the current grid
document.getElementById('export-grid-btn').addEventListener('click', () => {
  const p = getP();
  const sl = p.exportSize;
  const s = sl / (2 * Math.sin(Math.PI / SHAPE.sides));  // circumradius in mm
  const r = p.radius * sl;
  const cells = SHAPE.grid(Math.round(p.gridR));

  const paths = [];
  let xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity;

  for (const cell of cells) {
    const { x: px, y: py } = SHAPE.cell2px(cell, s);
    const rot = SHAPE.cellRot(cell);
    let pts = tileOutline(px, py, s, r, p.angle, p.angular, SHAPE.sides, rot);
    pts = smoothSides(pts, p.sideSmooth, px, py, p.angle);
    if (p.roundEdge > 0 || p.roundVtx > 0) pts = roundCorners(pts, p.roundEdge * sl, p.roundVtx * sl);
    const fp = pts.map(pt => ({ x: pt.x, y: -pt.y }));
    for (const pt of fp) {
      if (pt.x < xMin) xMin = pt.x;
      if (pt.x > xMax) xMax = pt.x;
      if (pt.y < yMin) yMin = pt.y;
      if (pt.y > yMax) yMax = pt.y;
    }
    paths.push(fp.map((pt, i) =>
      (i === 0 ? 'M' : 'L') + pt.x.toFixed(4) + ' ' + pt.y.toFixed(4)
    ).join(' ') + ' Z');
  }

  const margin = 1;
  const mx = xMin - margin, my = yMin - margin;
  const Mx = xMax + margin, My = yMax + margin;

  const svg =
`<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     viewBox="${mx} ${my} ${Mx - mx} ${My - my}"
     width="${(Mx - mx).toFixed(2)}mm" height="${(My - my).toFixed(2)}mm">
  ${paths.map(d => `<path d="${d}" fill="none" stroke="black" stroke-width="0.1"/>`).join('\n  ')}
</svg>`;

  const sn = SHAPE.name.toLowerCase();
  const jt = p.angular ? 'ang' : 'arc';
  const ss2 = p.sideSmooth > 0.001 ? `-ss${(p.sideSmooth * 100).toFixed(0)}` : '';
  downloadSVG(svg, `${sn}-grid-${p.angle}deg-r${(p.radius * 100).toFixed(0)}-re${(p.roundEdge * 1000).toFixed(0)}-rv${(p.roundVtx * 1000).toFixed(0)}${ss2}-${p.exportSize}mm-${jt}-${cells.length}tiles.svg`);
});

// ============================================================
//  URL state persistence
// ============================================================

const CHECKBOXES = ['show-original', 'show-circles', 'show-single', 'show-junction', 'show-stats'];

function saveToUrl() {
  const params = new URLSearchParams();
  sliders.forEach(s => params.set(s.id, document.getElementById(s.id).value));
  CHECKBOXES.forEach(id => params.set(id, document.getElementById(id).checked ? '1' : '0'));
  params.set('angular', document.getElementById('joint-angular').checked ? '1' : '0');
  params.set('scheme', document.getElementById('scheme').value);
  params.set('sides', SHAPE.sides);
  history.replaceState(null, '', '#' + params.toString());
}

function loadFromUrl() {
  const hash = location.hash.slice(1);
  if (!hash) return;
  const params = new URLSearchParams(hash);
  sliders.forEach(s => {
    if (params.has(s.id)) {
      const el = document.getElementById(s.id);
      el.value = params.get(s.id);
      document.getElementById(s.vid).textContent = s.fmt(+el.value);
    }
  });
  CHECKBOXES.forEach(id => {
    if (params.has(id)) document.getElementById(id).checked = params.get(id) === '1';
  });
  if (params.has('angular')) {
    const ang = params.get('angular') === '1';
    document.getElementById('joint-angular').checked = ang;
    document.getElementById('joint-circular').checked = !ang;
  }
  if (params.has('scheme')) {
    const idx = +params.get('scheme');
    document.getElementById('scheme').value = idx;
    setScheme(idx);
  }
  if (params.has('sides')) {
    setShape(+params.get('sides'));
  }
}

// ============================================================
//  Controls wiring
// ============================================================

const sliders = [
  { id: 'angle',   vid: 'v-angle',   fmt: v => v.toFixed(1) + '\u00B0' },
  { id: 'radius',  vid: 'v-radius',  fmt: v => v.toFixed(2) + ' \u00D7 side' },
  { id: 'round-edge', vid: 'v-round-edge', fmt: v => (+v).toFixed(3) + ' \u00D7 side' },
  { id: 'round-vtx',  vid: 'v-round-vtx',  fmt: v => (+v).toFixed(3) + ' \u00D7 side' },
  { id: 'side-smooth', vid: 'v-side-smooth', fmt: v => v + '%' },
  { id: 'thickness', vid: 'v-thickness', fmt: v => (+v).toFixed(1) + ' mm' },
  { id: 'export-size', vid: 'v-export-size', fmt: v => v + ' mm' },
  { id: 'size',    vid: 'v-size',    fmt: v => v + '%' },
  { id: 'grid',    vid: 'v-grid',    fmt: v => v },
  { id: 'explode', vid: 'v-explode', fmt: v => v + '%' },
  { id: 'tilt',    vid: 'v-tilt',    fmt: v => v + '\u00B0' },
  { id: 'perspective', vid: 'v-perspective', fmt: v => v + '%' },
  { id: 'rotation', vid: 'v-rotation', fmt: v => v + '\u00B0' },
];

function draw() { animP = null; animLoop(); }  // immediate (resize, init)
function onInput() { saveToUrl(); startAnim(); }

const perspGroup = document.getElementById('perspective-group');
function syncPerspVisibility() {
  perspGroup.style.display = +document.getElementById('tilt').value > 0 ? '' : 'none';
}
// Capture default values from HTML, wire up input + label-click-to-reset
const sliderDefaults = {};
// "Boring" industry-standard values — plain polygon, no twist, no rounding
const sliderBoring = {
  'angle': '0', 'radius': '0', 'round-edge': '0', 'round-vtx': '0',
  'side-smooth': '0', 'thickness': '2', 'export-size': '30',
  'size': '85', 'grid': '3', 'explode': '0',
  'tilt': '0', 'perspective': '45', 'rotation': '0',
};
sliders.forEach(s => {
  const el = document.getElementById(s.id);
  sliderDefaults[s.id] = el.defaultValue;
  el.addEventListener('input', () => {
    document.getElementById(s.vid).textContent = s.fmt(+el.value);
    if (s.id === 'tilt') syncPerspVisibility();
    onInput();
  });
  // Click label text to reset slider to boring/zero value (animated)
  const label = el.closest('.group').querySelector('label');
  label.addEventListener('click', e => {
    if (e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT') return;
    if (e.target.closest('.val-input') || e.target.id === s.vid) return;
    e.preventDefault();
    el.value = sliderBoring[s.id] ?? el.min;
    document.getElementById(s.vid).textContent = s.fmt(+el.value);
    if (s.id === 'tilt') syncPerspVisibility();
    onInput();
  });
  // Click value span to type in a number directly
  const valSpan = document.getElementById(s.vid);
  valSpan.addEventListener('click', e => {
    e.preventDefault();
    e.stopPropagation();
    if (valSpan.querySelector('.val-input')) return;  // already editing
    const step = +el.step;
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'val-input';
    input.value = +el.value;
    valSpan.textContent = '';
    valSpan.appendChild(input);
    input.focus();
    input.select();
    const commit = () => {
      let v = parseFloat(input.value);
      if (isNaN(v)) v = +el.value;  // keep current on bad input
      if (step >= 1) v = Math.round(v);
      else v = Math.round(v / step) * step;
      el.value = v;
      valSpan.textContent = s.fmt(+el.value);
      if (s.id === 'tilt') syncPerspVisibility();
      onInput();
    };
    input.addEventListener('blur', commit);
    input.addEventListener('keydown', e => {
      if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
      if (e.key === 'Escape') { e.preventDefault(); valSpan.textContent = s.fmt(+el.value); }
    });
  });
});
document.querySelectorAll('input[type=checkbox]').forEach(cb =>
  cb.addEventListener('change', onInput)
);
document.getElementById('scheme').addEventListener('change', () => {
  setScheme(+document.getElementById('scheme').value);
  onInput();
});
document.querySelectorAll('input[name="sides"]').forEach(radio =>
  radio.addEventListener('change', () => {
    setShape(+radio.value);
    onInput();
  })
);
document.querySelectorAll('input[name="joint"]').forEach(radio =>
  radio.addEventListener('change', onInput)
);
document.getElementById('randomize-btn').addEventListener('click', () => {
  const rng = (min, max, step) => {
    const steps = Math.round((max - min) / step);
    return min + Math.round(Math.random() * steps) * step;
  };
  const tileSliders = [
    { id: 'angle',       vid: 'v-angle',       min: -SHAPE.maxTwist, max: SHAPE.maxTwist, step: 0.5, fmt: v => v.toFixed(1) + '\u00B0' },
    { id: 'radius',      vid: 'v-radius',      min: 0.05, max: 0.45, step: 0.01, fmt: v => v.toFixed(2) + ' \u00D7 side' },
    { id: 'round-edge',  vid: 'v-round-edge',  min: 0, max: 0.1, step: 0.001, fmt: v => (+v).toFixed(3) + ' \u00D7 side' },
    { id: 'round-vtx',   vid: 'v-round-vtx',   min: 0, max: 0.15, step: 0.005, fmt: v => (+v).toFixed(3) + ' \u00D7 side' },
    { id: 'side-smooth', vid: 'v-side-smooth',  min: 0, max: 100, step: 1, fmt: v => v + '%' },
    { id: 'thickness',   vid: 'v-thickness',    min: 1, max: 5, step: 0.1, fmt: v => (+v).toFixed(1) + ' mm' },
    { id: 'export-size', vid: 'v-export-size',  min: 15, max: 50, step: 1, fmt: v => v + ' mm' },
  ];
  tileSliders.forEach(s => {
    const val = rng(s.min, s.max, s.step);
    const el = document.getElementById(s.id);
    el.value = val;
    document.getElementById(s.vid).textContent = s.fmt(+el.value);
  });
  // Random shape, then clamp angle to new max
  const sides = [3, 4, 6][Math.floor(Math.random() * 3)];
  setShape(sides);
  const angleEl = document.getElementById('angle');
  if (+angleEl.value > SHAPE.maxTwist) angleEl.value = SHAPE.maxTwist;
  document.getElementById('v-angle').textContent = (+angleEl.value).toFixed(1) + '\u00B0';
  // Coin-flip angular vs circular
  const ang = Math.random() > 0.5;
  document.getElementById('joint-angular').checked = ang;
  document.getElementById('joint-circular').checked = !ang;
  onInput();
});
document.getElementById('randomize-display-btn').addEventListener('click', () => {
  const rng = (min, max, step) => {
    const steps = Math.round((max - min) / step);
    return min + Math.round(Math.random() * steps) * step;
  };
  const displaySliders = [
    { id: 'size',        vid: 'v-size',        min: 30, max: 150, step: 1, fmt: v => v + '%' },
    { id: 'explode',     vid: 'v-explode',     min: 0,  max: 30,  step: 1, fmt: v => v + '%' },
    { id: 'tilt',        vid: 'v-tilt',        min: 0,  max: 55,  step: 1, fmt: v => v + '\u00B0' },
    { id: 'perspective', vid: 'v-perspective',  min: 10, max: 60,  step: 1, fmt: v => v + '%' },
    { id: 'rotation',    vid: 'v-rotation',     min: -180, max: 180, step: 1, fmt: v => v + '°' },
    { id: 'grid',        vid: 'v-grid',         min: 3,   max: 7,   step: 1, fmt: v => v },
  ];
  displaySliders.forEach(s => {
    const val = rng(s.min, s.max, s.step);
    document.getElementById(s.id).value = val;
    document.getElementById(s.vid).textContent = s.fmt(val);
  });
  // Random theme
  const schemeEl = document.getElementById('scheme');
  schemeEl.value = Math.floor(Math.random() * schemeEl.options.length);
  setScheme(+schemeEl.value);
  syncPerspVisibility();
  onInput();
});
// ============================================================
//  Play Demo
// ============================================================
let demoRaf = null, demoFrom = null, demoTo = null, demoStart = 0;
let demoStep = 0;
const DEMO_DUR = 2000; // ms
const DEMO_SHAPES = [6, 4, 3]; // hex → square → triangle

function cubicInOut(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

// Demo state uses raw slider values (no getP() conversion) to avoid scale mismatches.
const DEMO_SLIDERS = [
  { key: 'angle',      id: 'angle',       vid: 'v-angle',       fmt: v => v.toFixed(1) + '\u00B0' },
  { key: 'radius',     id: 'radius',      vid: 'v-radius',      fmt: v => v.toFixed(2) + ' \u00D7 side' },
  { key: 'roundEdge',  id: 'round-edge',  vid: 'v-round-edge',  fmt: v => (+v).toFixed(3) + ' \u00D7 side' },
  { key: 'roundVtx',   id: 'round-vtx',   vid: 'v-round-vtx',   fmt: v => (+v).toFixed(3) + ' \u00D7 side' },
  { key: 'sideSmooth', id: 'side-smooth', vid: 'v-side-smooth',  fmt: v => Math.round(v) + '%' },
  { key: 'thickness',  id: 'thickness',   vid: 'v-thickness',    fmt: v => (+v).toFixed(1) + ' mm' },
  { key: 'exportSize', id: 'export-size', vid: 'v-export-size',  fmt: v => Math.round(v) + ' mm' },
  { key: 'size',       id: 'size',        vid: 'v-size',         fmt: v => Math.round(v) + '%' },
  { key: 'explode',    id: 'explode',     vid: 'v-explode',      fmt: v => Math.round(v) + '%' },
  { key: 'tilt',       id: 'tilt',        vid: 'v-tilt',         fmt: v => Math.round(v) + '\u00B0' },
  { key: 'perspective',id: 'perspective', vid: 'v-perspective',  fmt: v => Math.round(v) + '%' },
  { key: 'rotation',   id: 'rotation',    vid: 'v-rotation',     fmt: v => Math.round(v) + '\u00B0' },
  { key: 'gridR',      id: 'grid',        vid: 'v-grid',         fmt: v => Math.round(v) },
];

function demoRandomTarget(forceSides) {
  const rng = (min, max, step) => {
    const steps = Math.round((max - min) / step);
    return min + Math.round(Math.random() * steps) * step;
  };
  const sides = forceSides || DEMO_SHAPES[Math.floor(demoStep / 5) % DEMO_SHAPES.length];
  const S = SHAPES[sides];
  demoStep++;
  return {
    angle:      rng(-S.maxTwist, S.maxTwist, 0.5),
    radius:     rng(0.05, 0.45, 0.01),
    roundEdge:  rng(0, 0.1, 0.001),
    roundVtx:   rng(0, 0.15, 0.005),
    sideSmooth: rng(0, 100, 1),
    thickness:  rng(1, 5, 0.1),
    exportSize: rng(15, 50, 1),
    size:       rng(30, 150, 1),
    explode:    rng(0, 30, 1),
    tilt:       rng(0, 55, 1),
    perspective:rng(10, 60, 1),
    rotation:   rng(-90, 90, 1),
    gridR:      rng(3, 6, 1),
    angular:    Math.random() > 0.5,
    scheme:     Math.floor(Math.random() * document.getElementById('scheme').options.length),
    sides:      sides,
  };
}

function demoSnapshotCurrent() {
  const snap = { sides: SHAPE.sides, angular: document.getElementById('joint-angular').checked,
    scheme: +document.getElementById('scheme').value };
  DEMO_SLIDERS.forEach(s => { snap[s.key] = +document.getElementById(s.id).value; });
  return snap;
}

function demoApply(snap) {
  setShape(snap.sides);
  DEMO_SLIDERS.forEach(s => {
    document.getElementById(s.id).value = snap[s.key];
    document.getElementById(s.vid).textContent = s.fmt(+document.getElementById(s.id).value);
  });
  document.getElementById('joint-angular').checked = snap.angular;
  document.getElementById('joint-circular').checked = !snap.angular;
  setScheme(snap.scheme);
  document.getElementById('scheme').value = snap.scheme;
  syncPerspVisibility();
}

const DEMO_LERP_KEYS = DEMO_SLIDERS.map(s => s.key);

function demoLerp(from, to, t) {
  const out = {};
  for (const k of DEMO_LERP_KEYS) {
    out[k] = from[k] + (to[k] - from[k]) * t;
  }
  // Discrete: snap at halfway
  out.angular = t < 0.5 ? from.angular : to.angular;
  out.scheme  = t < 0.5 ? from.scheme  : to.scheme;
  out.sides   = t < 0.5 ? from.sides   : to.sides;
  return out;
}

function demoLoop(ts) {
  if (!demoRaf) return;
  const elapsed = ts - demoStart;
  const t = Math.min(1, elapsed / DEMO_DUR);
  const eased = cubicInOut(t);
  const snap = demoLerp(demoFrom, demoTo, eased);
  demoApply(snap);
  // Draw directly with interpolated params (bypass normal anim system)
  animP = null;
  drawWithP(getP());
  if (t < 1) {
    demoRaf = requestAnimationFrame(demoLoop);
  } else {
    // Cycle: current target becomes new start, pick new target
    demoFrom = { ...demoTo };
    demoTo = demoRandomTarget();
    demoStart = ts;
    demoRaf = requestAnimationFrame(demoLoop);
  }
}

document.getElementById('demo-btn').addEventListener('click', () => {
  const btn = document.getElementById('demo-btn');
  if (demoRaf) {
    // Stop demo
    cancelAnimationFrame(demoRaf);
    demoRaf = null;
    btn.classList.remove('active');
    btn.textContent = 'Play Demo';
    saveToUrl();
    return;
  }
  // Start demo — begin from current shape, rotate after 5 steps
  btn.classList.add('active');
  btn.textContent = 'Stop Demo';
  const curIdx = DEMO_SHAPES.indexOf(SHAPE.sides);
  demoStep = (curIdx >= 0 ? curIdx : 0) * 5;
  demoFrom = demoSnapshotCurrent();
  demoTo = demoRandomTarget(SHAPE.sides);
  demoStart = performance.now();
  demoRaf = requestAnimationFrame(demoLoop);
});

// ============================================================
//  Canvas sizing & kick-off
// ============================================================

function resize() {
  const main = document.getElementById('main');
  // Zero canvas so its old intrinsic size doesn't inflate the container
  cvs.width = 1;
  cvs.height = 1;
  cvs.width  = Math.max(100, main.clientWidth);
  cvs.height = Math.max(100, main.clientHeight);
  draw();
}
document.getElementById('close-stats-btn').addEventListener('click', () => {
  document.getElementById('show-stats').checked = false;
  onInput();
});
setScheme(0);
loadFromUrl();
syncPerspVisibility();
// Prevent Randomize buttons inside <summary> from toggling the <details>
document.querySelectorAll('.section-wrap summary button').forEach(btn => {
  btn.addEventListener('click', e => e.preventDefault());
});

// ---- Mobile sidebar toggle ----
document.getElementById('sidebar-toggle').addEventListener('click', () => {
  const sb = document.getElementById('sidebar');
  sb.classList.toggle('hidden');
  resize();
});

window.addEventListener('resize', resize);
window.addEventListener('hashchange', () => { loadFromUrl(); syncPerspVisibility(); onInput(); });
resize();
</script>
</body>
</html>
